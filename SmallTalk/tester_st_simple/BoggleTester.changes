----QUIT----2023-03-15T12:25:06.404843+01:00 Pharo10-SNAPSHOT-64bit-179ef65.image priorSource: 0!----QUIT----2023-03-15T12:25:36.467018+01:00 Pharo10-SNAPSHOT-64bit-179ef65.image priorSource: 0!----QUIT----2024-01-25T10:32:23.892-05:00 BoggleTester.image priorSource: 99!'From Pharo11.0.0 of 22 January 2024 [Build information: Pharo-11.0.0+build.722.sha.7b1fe353f74b22e8aa4a429fe929f30e71e0fa86 (64 Bit)] on 25 January 2024 at 10:22:09.423 am'!TestCase subclass: #BoggleTest	instanceVariableNames: ''	classVariableNames: ''	package: 'CPS506'!!BoggleTest methodsFor: 'tests' stamp: 'AU 1/25/2024 10:04'!test_given_2x2	| board words found |	board := #( #( $e $a ) #( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := (Boggle new) search: board for: words.		self assert: found isDictionary.	self assert: (self words: found legal: words).	self assert: (self words: found board: board).		"Only when the 'found' result valid will a score be assigned"	"Compute score next"	! !!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 1/24/2024 10:58'!words: found board: board	found keysDo: [ :k |		| pts |		pts := found at: k.		1 to: pts size do: [ :i |			| x y cf cb |			x := (pts at: i) x.			y := (pts at: i) y.				cf := k at: i.			cb := ((board at: x) at: y).			cf = cb ifFalse: [ ^false ].  		].	].	^ true.	! !!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 1/23/2024 12:25'!words: found legal: words	| wordset |		wordset := words asSet.		found keysDo: [ :w | (wordset includes: w) ifFalse: [ ^false ]  ].		^true.! !----End fileIn----!'From Pharo11.0.0 of 22 January 2024 [Build information: Pharo-11.0.0+build.722.sha.7b1fe353f74b22e8aa4a429fe929f30e71e0fa86 (64 Bit)] on 25 January 2024 at 10:22:14.225 am'!Object subclass: #Boggle	instanceVariableNames: ''	classVariableNames: ''	package: 'CPS506'!!Boggle methodsFor: 'as yet unclassified' stamp: 'AU 1/25/2024 10:21'!search: board for: words		^ Dictionary 	with: 'a'->{(1@2)} 						with: 'at'->{(1@2).(2@2)} 						with: 'seat'->{(2@1).(1@1).(1@2).(2@2)}													! !----End fileIn----!----SNAPSHOT----2024-01-25T10:34:11.114-05:00 BoggleTester.image priorSource: 198!----SNAPSHOT----2024-01-25T10:35:34.784-05:00 BoggleTester.image priorSource: 2162!----SNAPSHOT----2024-01-25T10:43:08.895-05:00 BoggleTester.image priorSource: 2246!----QUIT----2024-01-25T10:43:51.343-05:00 BoggleTester.image priorSource: 2331!----SNAPSHOT----2024-01-25T10:44:35.641-05:00 BoggleTester.image priorSource: 2416!----QUIT----2024-01-25T10:44:38.137-05:00 BoggleTester.image priorSource: 2497!----QUIT/NOSAVE----2024-01-25T10:44:56.066-05:00 BoggleTester.image priorSource: 2582!----QUIT/NOSAVE----2024-01-25T10:45:28.971-05:00 BoggleTester.image priorSource: 2582!----QUIT/NOSAVE----2024-01-25T10:45:41.807-05:00 BoggleTester.image priorSource: 2582!----QUIT----2024-01-25T10:47:07.918-05:00 BoggleTester.image priorSource: 2582!----QUIT/NOSAVE----2024-01-25T10:47:15.144-05:00 BoggleTester.image priorSource: 2927!----QUIT/NOSAVE----2024-01-25T10:47:30.945-05:00 BoggleTester.image priorSource: 2927!----QUIT/NOSAVE----2024-01-25T10:47:53.416-05:00 BoggleTester.image priorSource: 2927!----SNAPSHOT----2024-01-25T10:55:48.378-05:00 BoggleTester.image priorSource: 2927!!BoggleTest methodsFor: 'tests' stamp: 'AU 1/25/2024 11:12' prior: 33555050!test_given_2x2	| board words found score word_points |	board := #( #( $e $a ) #( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := (Boggle new) search: board for: words.		self assert: found isDictionary.	self assert: (self words: found legal: words).	self assert: (self words: found board: board).		word_points := #(1 2 4 6 9 12 16 20).	score := 0.		found keysDo: [ :k | 							].	^score			! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/25/2024 11:14' prior: 33557867!test_given_2x2	| board words found score word_points |	board := #( #( $e $a ) #( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := (Boggle new) search: board for: words.		self assert: found isDictionary.	self assert: (self words: found legal: words).	self assert: (self words: found board: board).		word_points := #(1 2 4 6 9 12 16 20).	score := 0.		found keysDo: [ :k | 		| len |		len := k size.		len > 8 ifTrue: [ score := score + 20 ] ifFalse: [ score := score + (word_points at: len) ].					].	^score			! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/25/2024 11:15' prior: 33558394!test_given_2x2	| board words found score word_points |	board := #( #( $e $a ) #( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := (Boggle new) search: board for: words.		self assert: found isDictionary.	self assert: (self words: found legal: words).	self assert: (self words: found board: board).		word_points := #(1 2 4 6 9 12 16 20).	score := 0.		found keysDo: [ :k | 		score := score + (k size > 8) ifTrue: [ 20 ] ifFalse: [ word_points at: k size ].	].	^score			! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/25/2024 11:17' prior: 33559040!test_given_2x2	| board words found score word_points |	board := #( #( $e $a ) #( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := (Boggle new) search: board for: words.		self assert: found isDictionary.	self assert: (self words: found legal: words).	self assert: (self words: found board: board).		word_points := #(1 2 4 6 9 12 16 20).	score := 0.		found keysDo: [ :k | 		score := score + ( k size > 8 ifTrue: [ 20 ] ifFalse: [ word_points at: k size ] ).	].	^score			! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/25/2024 11:18' prior: 33559642!test_given_2x2	| board words found score wpts |	board := #( #( $e $a ) #( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := (Boggle new) search: board for: words.		self assert: found isDictionary.	self assert: (self words: found legal: words).	self assert: (self words: found board: board).		wpts := #(1 2 4 6 9 12 16 20).	score := 0.		found keysDo: [ :k | score := score + ( k size > 8 ifTrue: [ 20 ] ifFalse: [ wpts at: k size ] ) ].	^score			! !----QUIT----2024-01-25T11:22:58.696-05:00 BoggleTester.image priorSource: 3272!!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2024 16:14'!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).								dice_shuf := dice_arr shuffled.	dice_shuf := dice_shuf collect: [ :e | e atRandom ].		Transcript show: dice_shuf; cr		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:14' prior: 33560903!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).								dice_shuf := dice_arr shuffled.	dice_shuf := dice_shuf collect: [ :e | e atRandom ].		Transcript clear; show: dice_shuf; cr		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:16' prior: 33561390!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := {(Array new: 4).(Array new: 4).(Array new: 4).(Array new: 4)}.	dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		"Transcript clear; show: dice_shuf; cr"	Transcript clear; show: board class; cr		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:17' prior: 33561884!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := {(Array new: 4).(Array new: 4).(Array new: 4).(Array new: 4)}.	dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		"Transcript clear; show: dice_shuf; cr"	Transcript clear; show: (board at: 2) class; cr		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:22' prior: 33562461!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).		board := {(Array new: 4).(Array new: 4).(Array new: 4).(Array new: 4)}.	dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].	board := (Array new: 4)		at: 1 put: ( {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)} );		at: 2 put: ( {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)} );		at: 3 put: ( {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)} );		at: 4 put: ( {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)} ).	Transcript show: board; cr		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:23' prior: 33563046!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).		board := {(Array new: 4).(Array new: 4).(Array new: 4).(Array new: 4)}.	dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].	board := (Array new: 4)		at: 1 put: ( {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)} );		at: 2 put: ( {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)} );		at: 3 put: ( {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)} );		at: 4 put: ( {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)} ).	Transcript show: (board at: 1); cr		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:24' prior: 33563981!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).		board := {(Array new: 4).(Array new: 4).(Array new: 4).(Array new: 4)}.	dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].	board := (Array new: 4)		at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)};		at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)};		at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)};		at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.	Transcript show: (board at: 1); cr		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:24' prior: 33564924!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).		board := {(Array new: 4).(Array new: 4).(Array new: 4).(Array new: 4)}.	dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].	board := (Array new: 4)		at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)};		at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)};		at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)};		at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.	Transcript show: board; cr		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:25' prior: 33565851!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).		board := {(Array new: 4).(Array new: 4).(Array new: 4).(Array new: 4)}.	dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].	board := (Array new: 4)		at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)};		at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)};		at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)};		at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.	Transcript show: dice_shuf; cr	"Transcript show: board; cr"		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:25' prior: 33566770!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).		board := {(Array new: 4).(Array new: 4).(Array new: 4).(Array new: 4)}.	dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].	board := (Array new: 4)		at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)};		at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)};		at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)};		at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.	Transcript show: dice_shuf; cr.	Transcript show: board; cr		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:27' prior: 33567723!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).		board := {(Array new: 4).(Array new: 4).(Array new: 4).(Array new: 4)}.	dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].	board := Array new: 4.	board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.	board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.	board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.	board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.	Transcript show: dice_shuf; cr.	Transcript show: board; cr		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:28' prior: 33568675!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).		board := {(Array new: 4).(Array new: 4).(Array new: 4).(Array new: 4)}.	10 timesRepeat: [		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board := Array new: 4.		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.			]	"Transcript show: dice_shuf; cr."	"Transcript show: board; cr"		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:29' prior: 33560246!test_given_2x2	| board words found score wpts |	board := #( #( $e $a ) #( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		self assert: found isDictionary.	self assert: (self words: found legal: words).	self assert: (self words: found board: board).		wpts := #(1 2 4 6 9 12 16 20).	score := 0.		found keysDo: [ :k | score := score + ( k size > 8 ifTrue: [ 20 ] ifFalse: [ wpts at: k size ] ) ].	^score			! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2024 16:30'!search: board for: words		^ Dictionary 	with: 'a'->{(1@2)} 						with: 'at'->{(1@2).(2@2)} 						with: 'seat'->{(2@1).(1@1).(1@2).(2@2)}												! !Boggle removeSelector: #search:for:!!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:32' prior: 33569646!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).		board := {(Array new: 4).(Array new: 4).(Array new: 4).(Array new: 4)}.	10 timesRepeat: [		| res |		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board := Array new: 4.		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.					res := Boggle search: board for: words.		]	"Transcript show: dice_shuf; cr."	"Transcript show: board; cr"		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:34' prior: 33571500!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_3000.txt' asFileReference contents lines.	10 timesRepeat: [		| res |				" 'roll' dice. Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.					res := Boggle search: board for: words.		]	"Transcript show: dice_shuf; cr."	"Transcript show: board; cr"		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:34' prior: 33572568!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_3000.txt' asFileReference contents lines.	100 timesRepeat: [		| res |				" 'roll' dice. Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.					res := Boggle search: board for: words.		]	"Transcript show: dice_shuf; cr."	"Transcript show: board; cr"		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:34' prior: 33573709!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_3000.txt' asFileReference contents lines.	10 timesRepeat: [		| res |				" 'roll' dice. Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.					res := Boggle search: board for: words.		]	"Transcript show: dice_shuf; cr."	"Transcript show: board; cr"		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:52' prior: 33574851!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_500.txt' asFileReference contents lines.	10 timesRepeat: [		| res |				" 'roll' dice. Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.					res := Boggle search: board for: words.		]	"Transcript show: dice_shuf; cr."	"Transcript show: board; cr"		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:56' prior: 33575992!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_500.txt' asFileReference contents lines.	10 timesRepeat: [		| res ex |				" 'roll' dice. Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.			res := Boggle search: board for: words.			self assert: res class equals: Dictionary.		"[ res := Boggle search: board for: words ] on: Exception do: [ :e | ex := true ]."	]	"Transcript show: dice_shuf; cr."	"Transcript show: board; cr"		! !!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2024 16:59' prior: 33555540!words: found board: board	found keysDo: [ :k |		| pts |		pts := found at: k.				1 to: pts size do: [ :i |			| x y cf cb |			x := (pts at: i) x.			y := (pts at: i) y.				cf := k at: i.			cb := ((board at: x) at: y).			cf = cb ifFalse: [ ^false ].  		].	].	^ true.	! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 16:59' prior: 33577132!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_500.txt' asFileReference contents lines.	10 timesRepeat: [		| res ex |				" 'roll' dice. Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.			res := Boggle search: board for: words.			self assert: res isDictionary.		"[ res := Boggle search: board for: words ] on: Exception do: [ :e | ex := true ]."	]	"Transcript show: dice_shuf; cr."	"Transcript show: board; cr"		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 17:00' prior: 33578780!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_500.txt' asFileReference contents lines.	10 timesRepeat: [		| res |				" 'roll' dice. Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.			res := Boggle search: board for: words.			self assert: res isDictionary.		"[ res := Boggle search: board for: words ] on: Exception do: [ :e | ex := true ]."	]	"Transcript show: dice_shuf; cr."	"Transcript show: board; cr"		! !----SNAPSHOT----2024-01-29T17:00:58.084-05:00 BoggleTester.image priorSource: 6314!!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2024 17:16'!scoreOf: found! !!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2024 17:17' prior: 33581380!scoreOf: found	| wpts score |	wpts := #(1 2 4 6 9 12 16 20).	score := 0.			^found keysDo: [ :k | score := score + ( k size > 8 ifTrue: [ 20 ] ifFalse: [ wpts at: k size ] ) ].! !!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2024 17:17' prior: 33581492!scoreOf: found	| wpts score |	wpts := #(1 2 4 6 9 12 16 20).	score := 0.			^found keysDo: [ :k | score := score + ( k size > 8 ifTrue: [ 20 ] ifFalse: [ wpts at: k size ] ) ].	! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 17:18' prior: 33570654!test_given_2x2	| board words found  |	board := #( #( $e $a ) #( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		self assert: found isDictionary.	self assert: (self words: found legal: words).	self assert: (self words: found board: board).	^self scoreOf: found.			! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 17:18' prior: 33582035!test_given_2x2	| board words found  |	board := #( #( $e $a ) #( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		self assert: found isDictionary.	self assert: (self words: found legal: words).	self assert: (self words: found board: board).	^self scoreOf: found.					! !!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2024 17:22' prior: 33581769!scoreOf: found	| wpts score |	wpts := #(1 2 4 6 9 12 16 20).	score := 0.			score := 	(found keys) inject: 0 into: [ :s :e | s + ( e size > 8 ifTrue: [ 20 ] ifFalse: [ wpts at: e size ] ) ].			"found keysDo: [ :k | score := score + ( k size > 8 ifTrue: [ 20 ] ifFalse: [ wpts at: k size ] ) ]."		^score! !!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 1/29/2024 17:23' prior: 33582905!scoreOf: found	| wpts |	wpts := #(1 2 4 6 9 12 16 20).	^(found keys) inject: 0 into: [ :s :e | s + ( e size > 8 ifTrue: [ 20 ] ifFalse: [ wpts at: e size ] ) ].			"found keysDo: [ :k | score := score + ( k size > 8 ifTrue: [ 20 ] ifFalse: [ wpts at: k size ] ) ]."		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 17:33' prior: 33582461!test_given_2x2	| board words found  |	board := #( #( $e $a ) #( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		self assert: found isDictionary.	self assert: (self words: found legal: words).	self assert: (self words: found board: board).	^self scoreOf: found.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 17:34' prior: 33583668!test_given_2x2	| board words found  |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.		found := Boggle search: board for: words.	self assert: found isDictionary.	self assert: (self words: found legal: words).	self assert: (self words: found board: board).	^self scoreOf: found.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/29/2024 17:34' prior: 33584097!test_given_2x2	| board words found  |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		self assert: found isDictionary.	self assert: (self words: found legal: words).	self assert: (self words: found board: board).	^self scoreOf: found.				! !----QUIT----2024-01-29T17:35:04.753-05:00 BoggleTester.image priorSource: 26787!!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 08:49' prior: 33584533!test_given_2x2	| board words found  |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_1000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		self assert: found isDictionary.	self assert: (self words: found legal: words).	self assert: (self words: found board: board).	^self scoreOf: found.				! !!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 1/30/2024 08:49'!test_given_4x4	! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 08:49' prior: 33585485!test_given_4x4	| board words found  |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_1000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		self assert: found isDictionary.	self assert: (self words: found legal: words).	self assert: (self words: found board: board).	^self scoreOf: found.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 08:57' prior: 33585583!test_given_4x4	| board words found  |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		self assert: found isDictionary.	self assert: (self words: found legal: words).	self assert: (self words: found board: board).	^self scoreOf: found.				! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'AU 1/30/2024 09:02' prior: 33571226!search: board for: words	^Dictionary new		"^ Dictionary 	with: 'a'->{(1@2)} 						with: 'at'->{(1@2).(2@2)} 						with: 'seat'->{(2@1).(1@1).(1@2).(2@2)}"												! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 09:02' prior: 33580040!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_500.txt' asFileReference contents lines.	1000 timesRepeat: [		| res |				" 'roll' dice. Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.			res := Boggle search: board for: words.			self assert: res isDictionary.		"[ res := Boggle search: board for: words ] on: Exception do: [ :e | ex := true ]."	]	"Transcript show: dice_shuf; cr."	"Transcript show: board; cr"		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 09:03' prior: 33586783!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_500.txt' asFileReference contents lines.	10000 timesRepeat: [		| res |				" 'roll' dice. Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.			res := Boggle search: board for: words.			self assert: res isDictionary.		"[ res := Boggle search: board for: words ] on: Exception do: [ :e | ex := true ]."	]	"Transcript show: dice_shuf; cr."	"Transcript show: board; cr"		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 09:03' prior: 33588042!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_500.txt' asFileReference contents lines.	100000 timesRepeat: [		| res |				" 'roll' dice. Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.			res := Boggle search: board for: words.			self assert: res isDictionary.		"[ res := Boggle search: board for: words ] on: Exception do: [ :e | ex := true ]."	]	"Transcript show: dice_shuf; cr."	"Transcript show: board; cr"		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 09:03' prior: 33589302!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_500.txt' asFileReference contents lines.	1000 timesRepeat: [		| res |				" 'roll' dice. Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.			res := Boggle search: board for: words.			self assert: res isDictionary.		"[ res := Boggle search: board for: words ] on: Exception do: [ :e | ex := true ]."	]	"Transcript show: dice_shuf; cr."	"Transcript show: board; cr"		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 09:04' prior: 33590563!test_mass_4x4	"NOT testing for points. Looking for run-time errors"			| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_500.txt' asFileReference contents lines.	1000 timesRepeat: [		| res |				" Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.			" Should get through this method call without exceptions, and return a Dictionary "		res := Boggle search: board for: words.			self assert: res isDictionary.		"[ res := Boggle search: board for: words ] on: Exception do: [ :e | ex := true ]."	]	"Transcript show: dice_shuf; cr."	"Transcript show: board; cr"		! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'AU 1/30/2024 09:28' prior: 33586528!search: board for: words	^Dictionary new with: 'a'->{(1@2)}		"^ Dictionary 	with: 'a'->{(1@2)} 						with: 'at'->{(1@2).(2@2)} 						with: 'seat'->{(2@1).(1@1).(1@2).(2@2)}"												! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'AU 1/30/2024 09:29' prior: 33593170!search: board for: words			^Dictionary new with: 'a'->{(1@2)}			"^ Dictionary 	with: 'a'->{(1@2)} 						with: 'at'->{(1@2).(2@2)} 						with: 'seat'->{(2@1).(1@1).(1@2).(2@2)}"												! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'AU 1/30/2024 09:29' prior: 33593460!search: board for: words			^Dictionary with: 'a'->{(1@2)}			"^ Dictionary 	with: 'a'->{(1@2)} 						with: 'at'->{(1@2).(2@2)} 						with: 'seat'->{(2@1).(1@1).(1@2).(2@2)}"												! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 09:37' prior: 33585051!test_given_2x2	| board words found  |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_1000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	" Return score "	^self scoreOf: found.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 09:37' prior: 33594030!test_given_2x2	| board words found  |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_1000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" Return score "	^self scoreOf: found.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 09:37' prior: 33586019!test_given_4x4	| board words found  |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" Return score "	^self scoreOf: found.				! !----SNAPSHOT----2024-01-30T09:47:13.142-05:00 BoggleTester.image priorSource: 30459!----QUIT----2024-01-30T10:40:08.663-05:00 BoggleTester.image priorSource: 41324!!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 10:52' prior: 33594611!test_given_2x2	| board words found  |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_1000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: a (1 point), as at (4 points), ate eat tea sea set sat (24 points)	eats east seat sate (24 points), total = 53 	"		" Return score out of 53 "	^(self scoreOf: found) asString, '/53'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 10:53' prior: 33596002!test_given_2x2	| board words found  |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_1000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: a (1 point), as at (4 points), ate eat tea sea set sat (24 points)	eats east seat sate (24 points), total = 53 	"		" Return score out of 53 "	^'2x2 test: ', (self scoreOf: found) asString, '/53'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 10:54' prior: 33596740!test_given_2x2	| board words found  |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_1000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: a (1 point), as at (4 points), ate eat tea sea set sat (24 points)	eats east seat sate (24 points), total = 53 	"		" Return score out of 53 "	^'2x2 test: ', (self scoreOf: found) asString, '/53 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 10:55' prior: 33597492!test_given_2x2	| board words found score |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_1000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: a (1 point), as at (4 points), ate eat tea sea set sat (24 points)	eats east seat sate (24 points), total = 53 	"		" Return score out of 53 "	score := self scoreOf: found.	^'2x2 test: ', score asString, '/53 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 10:58' prior: 33595194!test_given_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" Return score out of xx "	score := self scoreOf: found.	^'2x2 test: ', score asString, '/53 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 10:58' prior: 33599048!test_given_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" Return score out of xx "	score := self scoreOf: found.	^'2x2 test: ', score asString, '/xx possible points'.				! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'AU 1/30/2024 10:58' prior: 33593755!search: board for: words			^Dictionary new			"^Dictionary with: 'a'->{(1@2)}"		"^ Dictionary 	with: 'a'->{(1@2)} 						with: 'at'->{(1@2).(2@2)} 						with: 'seat'->{(2@1).(1@1).(1@2).(2@2)}"												! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 10:59' prior: 33591822!test_mass_4x4 				| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_500.txt' asFileReference contents lines.	" NOT testing for points. Looking for run-time errors "	1000 timesRepeat: [		| res |				" Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.			" Should get through this method call without exceptions, and return a Dictionary "		res := Boggle search: board for: words.			self assert: res isDictionary.		"[ res := Boggle search: board for: words ] on: Exception do: [ :e | ex := true ]."	]	"Transcript show: dice_shuf; cr."	"Transcript show: board; cr"		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 10:59' prior: 33599766!test_given_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" Return score out of xx "	score := self scoreOf: found.	^'4x4 test: ', score asString, '/xx possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 11:10' prior: 33598260!test_given_2x2	| board words found score |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: a (1 point), as at (4 points), ate eat tea sea set sat (24 points)	eats east seat sate (24 points), total = 53 	"		" Return score out of 53 "	score := self scoreOf: found.	^'2x2 test: ', score asString, '/53 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 11:11' prior: 33602849!test_given_2x2	| board words found score |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: a (1 point), as at (4 points), eat tea sea set sat (24 points)	eats east seat sate (24 points), total = 53 	"		" Return score out of 53 "	score := self scoreOf: found.	^'2x2 test: ', score asString, '/53 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 11:14' prior: 33603637!test_given_2x2	| board words found score |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: a (1 point), as at (4 points), eat tea sea set (16 points),	east seat (12 points), total = 33 "		" Return score out of 53 "	score := self scoreOf: found.	^'2x2 test: ', score asString, '/33 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 11:32' prior: 33602131!test_given_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: a i (2 points), as at on up us (10 points), set son pet (12 points),	east nice save step vast even nose oven (48 points), 	event issue noise pause (36 points), session (16 points)	total = 33 "		" Return score out of xx "	score := self scoreOf: found.	^'4x4 test: ', score asString, '/xx possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 1/30/2024 11:33' prior: 33605191!test_given_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: (tell me if you find others that i've missed)	a i (2 points), as at on up us (10 points), set son pet (12 points),	east nice save step vast even nose oven (48 points), 	event issue noise pause (36 points), session (16 points)	total = 124 "		" Return score out of xx "	score := self scoreOf: found.	^'4x4 test: ', score asString, '/124 possible points'.				! !----QUIT----2024-01-30T11:33:49.165-05:00 BoggleTester.image priorSource: 41410!----QUIT/NOSAVE----2024-01-31T11:30:41.739-05:00 BoggleTester.image priorSource: 52582!!BoggleTest methodsFor: 'tests' stamp: 'AU 2/1/2024 10:09' prior: 33606117!test_given_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: (tell me if you find others that i've missed)	a i (2 points), 	as at on up us (10 points), 	set son pet (12 points),	east nice save step vast even nose oven (48 points), 	event issue noise pause (36 points), 	session (16 points)	total = 124 "		" Return score out of xx "	score := self scoreOf: found.	^'4x4 test: ', score asString, '/124 possible points'.				! !!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 2/1/2024 10:09' prior: 33583312!scoreOf: found	| wpts |	wpts := #(1 2 4 6 9 12 16 20).	^(found keys) inject: 0 into: [ :s :e | s + ( e size > 8 ifTrue: [ 20 ] ifFalse: [ wpts at: e size ] ) ].			! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/1/2024 10:10' prior: 33600795!test_mass_4x4 				| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_500.txt' asFileReference contents lines.	" NOT testing for points. Looking for run-time errors "	1000 timesRepeat: [		| res |				" Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.			" Should get through this method call without exceptions, and return a Dictionary "		res := Boggle search: board for: words.			self assert: res isDictionary.	]		! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'AU 2/1/2024 10:10' prior: 33600500!search: board for: words			^Dictionary new														! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'AU 2/1/2024 10:11' prior: 33609709!search: board for: words			" Your code here "			^Dictionary new														! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/1/2024 10:13' prior: 33604421!test_given_2x2	| board words found score |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: 	a (1 point) 	as at (4 points) 	eat tea sea set (16 points)	east seat (12 points) 	total = 33 "		" Return score out of 33 "	score := self scoreOf: found.	^'2x2 test: ', score asString, '/33 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/1/2024 10:14' prior: 33607262!test_given_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: (tell me if you find others that i've missed)	a i (2 points) 	as at on up us (10 points) 	set son pet (12 points)	east nice save step vast even nose oven (48 points) 	event issue noise pause (36 points) 	session (16 points)	total = 124 "		" Return score out of 124 "	score := self scoreOf: found.	^'4x4 test: ', score asString, '/124 possible points'.				! !!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 2/1/2024 10:14' prior: 33555897!words: found legal: words	| wordset |		wordset := words asSet.	found keysDo: [ :w | (wordset includes: w) ifFalse: [ ^false ]  ].		^true.! !----QUIT----2024-02-01T10:15:13.964-05:00 BoggleTester.image priorSource: 52582!----QUIT----2024-02-01T10:16:28.471-05:00 BoggleTester.image priorSource: 57512!----QUIT----2024-02-01T10:17:57.632-05:00 BoggleTester.image priorSource: 57594!----QUIT/NOSAVE----2024-02-05T14:31:54.232-05:00 BoggleTester.image priorSource: 57676!----QUIT/NOSAVE----2024-02-05T14:41:38.843-05:00 BoggleTester.image priorSource: 57676!!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 2/6/2024 09:15' prior: 33578418!words: found board: board	" Test if characters are actually at the coordinates "	found keysDo: [ :k |		| pts |		pts := found at: k.				1 to: pts size do: [ :i |			| x y cf cb |			x := (pts at: i) x.			y := (pts at: i) y.				cf := k at: i.			cb := ((board at: x) at: y).			cf = cb ifFalse: [ ^false ].  		].	].	" Test if character coordinates are unique "	found keysDo: [ :k |		| pts |		pts := found at: k.		pts size = pts asSet size ifFalse: [ ^false ].	].			" Test if characters form a chain "	found keysDo: [ :k |		| pts |		pts := found at: k.				1 to: pts size - 1 do: [ :i |			| pt1 pt2 |			pt1 := pts at: i.			pt2 := pts at: i+1.						].						].	^ true.	! !!ManifestCPS506 commentStamp: '<historical>' prior: 0!Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!ManifestCPS506 class methodsFor: 'code-critics' stamp: 'AU 2/6/2024 09:15'!ruleToDoRuleV1FalsePositive	^ #()! !!ManifestCPS506 class methodsFor: 'code-critics' stamp: 'AU 2/6/2024 09:15' prior: 33613558!ruleToDoRuleV1FalsePositive	^ #(#(#(#RGPackageDefinition #(#CPS506)) #'2024-02-06T09:15:34.684-05:00') )! !----SNAPSHOT----2024-02-06T09:15:42.767-05:00 BoggleTester.image priorSource: 57676!Smalltalk globals removeClassNamed: #AnObsoleteManifestCPS506!!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 2/6/2024 09:25' prior: 33612459!words: found board: board	" Test if characters are actually at the coordinates "	found keysDo: [ :k |		| pts |		pts := found at: k.				1 to: pts size do: [ :i |			| x y cf cb |			x := (pts at: i) x.			y := (pts at: i) y.				cf := k at: i.			cb := ((board at: x) at: y).			cf = cb ifFalse: [ ^false ].  		].	].	" Test if character coordinates are unique "	found keysDo: [ :k |		| pts |		pts := found at: k.		pts size = pts asSet size ifFalse: [ ^false ].	].			" Test if characters form a chain "	found keysDo: [ :k |		| pts |		pts := found at: k.				1 to: pts size - 1 do: [ :i |			| pt1 pt2 x_diff y_diff |			pt1 := pts at: i.			pt2 := pts at: i+1.			x_diff := (pt1 x - pt2 x) abs.			y_diff := (pt1 y - pt2 y) abs.			x_diff > 1 ifTrue: [ ^false ].			y_diff > 1 ifTrue: [ ^false ].		].	].	" Didn't return false earlier, words must be good!! "	^ true.	! !----SNAPSHOT----2024-02-06T09:26:45.303-05:00 BoggleTester.image priorSource: 59365!!Boggle class methodsFor: 'as yet unclassified' stamp: 'AU 2/6/2024 09:29' prior: 33609868!search: board for: words			" Your code here "			^Dictionary 	with: 'event'->{(2@4). (2@3). (3@2). (4@1). (4@2)} 				  	with: 'session'->{(4@3). (3@2). (2@2). (1@2). (1@1). (2@1). (3@1)} 					with: 'set'->{(2@2). (3@2). (4@2)} 					with: 'so'->{(1@2). (2@1)}. 			"^Dictionary new"														! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'AU 2/6/2024 09:31' prior: 33615113!search: board for: words			" Your code here "			^Dictionary 	with: 'event'->{(2@4). (2@3). (3@2). (4@1). (4@2)} 				  	with: 'session'->{(4@3). (3@2). (2@2). (1@2). (1@1). (2@1). (3@1)} 					with: 'set'->{(2@2). (2@4). (4@2)} 					with: 'so'->{(1@2). (2@1)}. 			"^Dictionary new"														! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'AU 2/6/2024 09:33' prior: 33615516!search: board for: words			" Your code here "			^Dictionary new														! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/6/2024 09:36' prior: 33610807!test_given_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: (tell me if you find others that i've missed)	a i (2 points) 	as on up us vs (10 points) 	pet set son (12 points)	east even nice save step vast  nose oven (48 points) 	event issue noise pause (36 points) 	session (16 points)	total = 124 "		" Return score out of 124 "	score := self scoreOf: found.	^'4x4 test: ', score asString, '/124 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/6/2024 09:37' prior: 33616085!test_given_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: (tell me if you find others that i've missed)	a i (2 points) 	as no on up us vs (12 points) 	pet set son (12 points)	ease east even nice nose oven save step vast (48 points) 	event issue noise pause (36 points) 	session (16 points)	total = 124 "		" Return score out of 124 "	score := self scoreOf: found.	^'4x4 test: ', score asString, '/124 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/6/2024 09:45' prior: 33617062!test_given_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: (tell me if you find others that i've missed)	a i (2 points) 	as no on so up us vs (14 points) 	net one pet set son sue ten use (32 points)	ease east even nose oven past save step vast (54 points) 	event issue noise pause (36 points) 	session (16 points)	total = 154 "		" Return score out of 124 "	score := self scoreOf: found.	^'4x4 test: ', score asString, '/124 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/6/2024 09:45' prior: 33618046!test_given_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: (tell me if you find others that i've missed)	a i (2 points) 	as no on so up us vs (14 points) 	net one pet set son sue ten use (32 points)	ease east even nose oven past save step vast (54 points) 	event issue noise pause (36 points) 	session (16 points)	total = 154 "		" Return score out of 124 "	score := self scoreOf: found.	^'4x4 test: ', score asString, '/154 possible points'.				! !----SNAPSHOT----2024-02-06T09:45:42.409-05:00 BoggleTester.image priorSource: 60502!----SNAPSHOT----2024-02-06T10:01:48.313-05:00 BoggleTester.image priorSource: 65551!----QUIT----2024-02-06T10:01:50.431-05:00 BoggleTester.image priorSource: 65637!----QUIT/NOSAVE----2024-02-06T10:03:19.722-05:00 BoggleTester.image priorSource: 65723!!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 2/8/2024 08:51'!test_large_8x8		self assert: true.! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/8/2024 09:00' prior: 33620401!test_large_8x8		| board words found score |	board := #( 	#( $o $c $n $e $a $s $r $a ) 					#( $c $r $i $s $h $t $i $r )  					#( $l $l $a $n $n $r $e $n )					#( $g $e $n $s $s $a $q $n )					#( $d $a $m $c $o $b $n $u ) 					#( $n $r $o $o $s $y $e $n )					#( $a $t $s $a $r $s $o $n )					#( $b $e $s $s $n $n $i $s ) ).	words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.	self assert: true.! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/8/2024 09:04' prior: 33620519!test_large_8x8		| board words found score |	board := #( 	#( $o $c $n $e $a $s $r $a ) 					#( $c $r $i $s $h $t $i $r )  					#( $l $l $a $n $n $r $e $n )					#( $g $e $n $s $s $a $q $n )					#( $d $a $m $c $o $b $n $u ) 					#( $n $r $o $o $s $y $e $n )					#( $a $t $s $a $r $s $o $n )					#( $b $e $s $s $n $n $i $s ) ).						words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.	" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	" Return score once all words are verified "	score := self scoreOf: found.	^ score.! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/8/2024 09:04' prior: 33621071!test_large_8x8		| board words found score |	board := #( 	#( $o $c $n $e $a $s $r $a ) 					#( $c $r $i $s $h $t $i $r )  					#( $l $l $a $n $n $r $e $n )					#( $g $e $n $s $s $a $q $n )					#( $d $a $m $c $o $b $n $u ) 					#( $n $r $o $o $s $y $e $n )					#( $a $t $s $a $r $s $o $n )					#( $b $e $s $s $n $n $i $s ) ).						words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.	" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	" Return score once all words are verified "	score := self scoreOf: found.	^'8x8 test: ', score asString, ' points'.! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/8/2024 09:05' prior: 33619053!test_given_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: (tell me if you find others that i've missed)	a i (2 points) 	as no on so up us vs (14 points) net one pet set son sue ten use (32 points)	ease east even nose oven past save step vast (54 points) event issue noise pause (36 points) 	session (16 points) total = 154 "		" Return score out of 124 "	score := self scoreOf: found.	^'4x4 test: ', score asString, '/154 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/8/2024 09:05' prior: 33610034!test_given_2x2	| board words found score |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: 	a (1 point) 	as at (4 points) eat tea sea set (16 points)	east seat (12 points) total = 33 "		" Return score out of 33 "	score := self scoreOf: found.	^'2x2 test: ', score asString, '/33 possible points'.				! !!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 2/8/2024 09:06'!test_mega_16x16	! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/8/2024 09:08' prior: 33624634!test_mega_16x16	| board words found score |	board := #( 	#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ ) 					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ ) ).						words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.	" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	" Return score once all words are verified "	score := self scoreOf: found.	^'8x8 test: ', score asString, ' points'.! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/8/2024 09:08' prior: 33624732!test_mega_16x16	| board words found score |	board := #( 	#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ ) 					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ )					#( $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ ) ).						words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.	" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	" Return score once all words are verified "	score := self scoreOf: found.	^'16x16 test: ', score asString, ' points'.! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/8/2024 09:12' prior: 33626043!test_mega_16x16	| board words found score |	board := #( 	#( $a $q $o $a $ $ $ $ $ $ $ $ $ $ $ $ ) 					#( $l $n $u $c $ $ $ $ $ $ $ $ $ $ $ $ )					#( $q $c $a $c $ $ $ $ $ $ $ $ $ $ $ $ )					#( $d $e $s $m $ $ $ $ $ $ $ $ $ $ $ $ )					#( $i $t $q $e $ $ $ $ $ $ $ $ $ $ $ $ )					#( $d $n $e $c $ $ $ $ $ $ $ $ $ $ $ $ )					#( $p $l $o $r $ $ $ $ $ $ $ $ $ $ $ $ )					#( $b $a $l $v $ $ $ $ $ $ $ $ $ $ $ $ )					#( $o $j $n $a $ $ $ $ $ $ $ $ $ $ $ $ )					#( $n $m $e $l $ $ $ $ $ $ $ $ $ $ $ $ )					#( $l $s $a $l $ $ $ $ $ $ $ $ $ $ $ $ )					#( $p $e $m $h $ $ $ $ $ $ $ $ $ $ $ $ )					#( $i $s $n $o $ $ $ $ $ $ $ $ $ $ $ $ )					#( $r $d $e $a $ $ $ $ $ $ $ $ $ $ $ $ )					#( $p $g $u $r $ $ $ $ $ $ $ $ $ $ $ $ )					#( $s $i $a $s $ $ $ $ $ $ $ $ $ $ $ $ ) ).						words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.	" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	" Return score once all words are verified "	score := self scoreOf: found.	^'16x16 test: ', score asString, ' points'.! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/8/2024 09:18' prior: 33627356!test_mega_16x16	| board words found score |	board := #( 	#( $a $q $o $a $u $s $i $e $a $r $t $u $e $l $r $o ) 					#( $l $n $u $c $r $s $u $r $s $d $i $r $z $t $o $m )					#( $q $c $a $c $l $o $d $q $t $y $i $y $c $r $a $v )					#( $d $e $s $m $p $a $n $t $s $e $m $t $d $e $s $t )					#( $i $t $q $e $e $t $r $o $a $b $n $o $a $h $n $a )					#( $d $n $e $c $r $p $o $l $v $n $e $z $s $m $i $m )					#( $p $l $o $r $s $s $i $s $t $t $u $g $c $t $o $g )					#( $b $a $l $v $r $i $d $n $m $o $l $s $b $a $n $v )					#( $o $j $n $a $o $y $l $o $i $f $g $a $e $s $z $a )					#( $n $m $e $l $l $s $e $n $n $p $i $r $m $c $i $n )					#( $l $s $a $l $n $m $u $c $r $l $a $r $m $b $a $m )					#( $p $e $m $h $z $a $r $n $y $e $c $l $p $e $s $r )					#( $i $s $n $o $u $s $t $a $o $s $c $e $i $c $i $o )					#( $r $d $e $a $s $d $o $l $d $l $e $s $r $l $o $m )					#( $p $g $u $r $l $v $o $c $l $s $e $r $b $m $e $m )					#( $s $i $a $s $n $a $p $r $m $u $r $h $t $o $s $c ) ).						words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.	" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	" Return score once all words are verified "	score := self scoreOf: found.	^'16x16 test: ', score asString, ' points'.! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/8/2024 09:19' prior: 33628733!test_mega_16x16	| board words found score |	board := #( 	#( $a $q $o $a $u $s $i $e $a $r $t $u $e $l $r $o ) 					#( $l $n $u $c $r $s $u $r $s $d $i $r $z $t $o $m )					#( $q $c $a $c $l $o $d $q $t $y $i $y $c $r $a $v )					#( $d $e $s $m $p $a $n $t $s $e $m $t $d $e $s $t )					#( $i $t $q $e $e $t $r $o $a $b $n $o $a $h $n $a )					#( $d $n $e $c $r $p $o $l $v $n $e $z $s $m $i $m )					#( $p $l $o $r $s $s $i $s $t $t $u $g $c $t $o $g )					#( $b $a $l $v $r $i $d $n $m $o $l $s $b $a $n $v )					#( $o $j $n $a $o $y $l $o $i $f $g $a $e $s $z $a )					#( $n $m $e $l $l $s $e $n $n $p $i $r $m $c $i $n )					#( $l $s $a $l $n $m $u $c $r $l $a $r $m $b $a $m )					#( $p $e $m $h $z $a $r $n $y $e $c $l $p $e $s $r )					#( $i $s $n $o $u $s $t $a $o $s $c $e $i $c $i $o )					#( $r $d $e $a $s $d $o $l $d $l $e $s $r $l $o $m )					#( $p $g $u $r $l $v $o $c $l $s $e $r $b $m $e $m )					#( $s $i $a $s $n $a $p $r $m $u $r $h $t $o $s $c ) ).						words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.	" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	" Return score once all words are verified "	score := self scoreOf: found.	^'16x16 test: ', score asString, ' points'.	! !----SNAPSHOT----2024-02-08T09:20:22.463-05:00 BoggleTester.image priorSource: 65723!----QUIT----2024-02-08T09:20:24.772-05:00 BoggleTester.image priorSource: 77365!----QUIT/NOSAVE----2024-02-08T09:22:50.343-05:00 BoggleTester.image priorSource: 77451!----QUIT/NOSAVE----2024-02-08T10:37:06.595-05:00 BoggleTester.image priorSource: 77451!----QUIT/NOSAVE----2024-02-08T10:59:48.585-05:00 BoggleTester.image priorSource: 77451!----QUIT/NOSAVE----2024-02-08T11:59:35.464-05:00 BoggleTester.image priorSource: 77451!!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 2/12/2024 16:52'!test_medium_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: (tell me if you find others that i've missed)	a i (2 points) 	as no on so up us vs (14 points) net one pet set son sue ten use (32 points)	ease east even nose oven past save step vast (54 points) event issue noise pause (36 points) 	session (16 points) total = 154 "		" Return score out of 124 "	score := self scoreOf: found.	^'4x4 test: ', score asString, '/154 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/12/2024 16:52'!test_small_2x2	| board words found score |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: 	a (1 point) 	as at (4 points) eat tea sea set (16 points)	east seat (12 points) total = 33 "		" Return score out of 33 "	score := self scoreOf: found.	^'2x2 test: ', score asString, '/33 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/12/2024 16:52' prior: 33633393!test_small_2x2	| board words found score |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: 	a (1 point) 	as at (4 points) eat tea sea set (16 points)	east seat (12 points) total = 33 "		" Return score out of 33 "	score := self scoreOf: found.	^'2x2 test: ', score asString, '/33 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/12/2024 16:55'!test_2a_given_2x2	| board words found score |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: 	a (1 point) 	as at (4 points) eat tea sea set (16 points)	east seat (12 points) total = 33 "		" Return score out of 33 "	score := self scoreOf: found.	^'2x2 test: ', score asString, '/33 possible points'.				! !BoggleTest removeSelector: #test_given_2x2!!BoggleTest methodsFor: 'tests' stamp: 'AU 2/12/2024 16:56'!test_2b_given_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: (tell me if you find others that i've missed)	a i (2 points) 	as no on so up us vs (14 points) net one pet set son sue ten use (32 points)	ease east even nose oven past save step vast (54 points) event issue noise pause (36 points) 	session (16 points) total = 154 "		" Return score out of 124 "	score := self scoreOf: found.	^'4x4 test: ', score asString, '/154 possible points'.				! !BoggleTest removeSelector: #test_given_4x4!!BoggleTest methodsFor: 'tests' stamp: 'AU 2/12/2024 16:56'!test_1_mass_4x4 				| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_500.txt' asFileReference contents lines.	" NOT testing for points. Looking for run-time errors "	1000 timesRepeat: [		| res |				" Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.			" Should get through this method call without exceptions, and return a Dictionary "		res := Boggle search: board for: words.			self assert: res isDictionary.	]		! !BoggleTest removeSelector: #test_mass_4x4!!BoggleTest methodsFor: 'tests' stamp: 'AU 2/12/2024 16:56'!test_3a_small_2x2	| board words found score |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: 	a (1 point) 	as at (4 points) eat tea sea set (16 points)	east seat (12 points) total = 33 "		" Return score out of 33 "	score := self scoreOf: found.	^'2x2 test: ', score asString, '/33 possible points'.				! !BoggleTest removeSelector: #test_small_2x2!!BoggleTest methodsFor: 'tests' stamp: 'AU 2/12/2024 16:56'!test_3b_medium_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: (tell me if you find others that i've missed)	a i (2 points) 	as no on so up us vs (14 points) net one pet set son sue ten use (32 points)	ease east even nose oven past save step vast (54 points) event issue noise pause (36 points) 	session (16 points) total = 154 "		" Return score out of 124 "	score := self scoreOf: found.	^'4x4 test: ', score asString, '/154 possible points'.				! !BoggleTest removeSelector: #test_medium_4x4!!BoggleTest methodsFor: 'tests' stamp: 'AU 2/12/2024 16:56'!test_3c_large_8x8		| board words found score |	board := #( 	#( $o $c $n $e $a $s $r $a ) 					#( $c $r $i $s $h $t $i $r )  					#( $l $l $a $n $n $r $e $n )					#( $g $e $n $s $s $a $q $n )					#( $d $a $m $c $o $b $n $u ) 					#( $n $r $o $o $s $y $e $n )					#( $a $t $s $a $r $s $o $n )					#( $b $e $s $s $n $n $i $s ) ).						words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.	" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	" Return score once all words are verified "	score := self scoreOf: found.	^'8x8 test: ', score asString, ' points'.! !BoggleTest removeSelector: #test_large_8x8!!BoggleTest methodsFor: 'tests' stamp: 'AU 2/12/2024 16:57'!test_3d_mega_16x16	| board words found score |	board := #( 	#( $a $q $o $a $u $s $i $e $a $r $t $u $e $l $r $o ) 					#( $l $n $u $c $r $s $u $r $s $d $i $r $z $t $o $m )					#( $q $c $a $c $l $o $d $q $t $y $i $y $c $r $a $v )					#( $d $e $s $m $p $a $n $t $s $e $m $t $d $e $s $t )					#( $i $t $q $e $e $t $r $o $a $b $n $o $a $h $n $a )					#( $d $n $e $c $r $p $o $l $v $n $e $z $s $m $i $m )					#( $p $l $o $r $s $s $i $s $t $t $u $g $c $t $o $g )					#( $b $a $l $v $r $i $d $n $m $o $l $s $b $a $n $v )					#( $o $j $n $a $o $y $l $o $i $f $g $a $e $s $z $a )					#( $n $m $e $l $l $s $e $n $n $p $i $r $m $c $i $n )					#( $l $s $a $l $n $m $u $c $r $l $a $r $m $b $a $m )					#( $p $e $m $h $z $a $r $n $y $e $c $l $p $e $s $r )					#( $i $s $n $o $u $s $t $a $o $s $c $e $i $c $i $o )					#( $r $d $e $a $s $d $o $l $d $l $e $s $r $l $o $m )					#( $p $g $u $r $l $v $o $c $l $s $e $r $b $m $e $m )					#( $s $i $a $s $n $a $p $r $m $u $r $h $t $o $s $c ) ).						words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.	" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	" Return score once all words are verified "	score := self scoreOf: found.	^'16x16 test: ', score asString, ' points'.	! !BoggleTest removeSelector: #test_mega_16x16!----SNAPSHOT----2024-02-12T16:57:36.561-05:00 BoggleTester.image priorSource: 77451!!BoggleTest methodsFor: 'tests' stamp: 'AU 2/12/2024 17:11' prior: 33634922!test_2a_given_2x2	| board words found score |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: 	a (1 point) 	as at (4 points) eat tea sea set (16 points)	east seat (12 points) total = 33 "		" Return score out of 33 "	score := self scoreOf: found.	^'2a - 2x2 test: ', score asString, '/33 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/12/2024 17:11' prior: 33635722!test_2b_given_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: (tell me if you find others that i've missed)	a i (2 points) 	as no on so up us vs (14 points) net one pet set son sue ten use (32 points)	ease east even nose oven past save step vast (54 points) event issue noise pause (36 points) 	session (16 points) total = 154 "		" Return score out of 124 "	score := self scoreOf: found.	^'2b - 4x4 test: ', score asString, '/154 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/12/2024 17:11' prior: 33637972!test_3a_small_2x2	| board words found score |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: 	a (1 point) 	as at (4 points) eat tea sea set (16 points)	east seat (12 points) total = 33 "		" Return score out of 33 "	score := self scoreOf: found.	^'3a - 2x2 test: ', score asString, ' points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/12/2024 17:11' prior: 33638781!test_3b_medium_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: (tell me if you find others that i've missed)	a i (2 points) 	as no on so up us vs (14 points) net one pet set son sue ten use (32 points)	ease east even nose oven past save step vast (54 points) event issue noise pause (36 points) 	session (16 points) total = 154 "		" Return score out of 124 "	score := self scoreOf: found.	^'3b - 4x4 test: ', score asString, ' points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/12/2024 17:11' prior: 33645041!test_3b_medium_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		score := self scoreOf: found.	^'3b - 4x4 test: ', score asString, ' points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/12/2024 17:11' prior: 33644268!test_3a_small_2x2	| board words found score |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	score := self scoreOf: found.	^'3a - 2x2 test: ', score asString, ' points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/12/2024 17:12' prior: 33639826!test_3c_large_8x8		| board words found score |	board := #( 	#( $o $c $n $e $a $s $r $a ) 					#( $c $r $i $s $h $t $i $r )  					#( $l $l $a $n $n $r $e $n )					#( $g $e $n $s $s $a $q $n )					#( $d $a $m $c $o $b $n $u ) 					#( $n $r $o $o $s $y $e $n )					#( $a $t $s $a $r $s $o $n )					#( $b $e $s $s $n $n $i $s ) ).						words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.	" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	" Return score once all words are verified "	score := self scoreOf: found.	^'3c - 8x8 test: ', score asString, ' points'.! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/12/2024 17:12' prior: 33640774!test_3d_mega_16x16	| board words found score |	board := #( 	#( $a $q $o $a $u $s $i $e $a $r $t $u $e $l $r $o ) 					#( $l $n $u $c $r $s $u $r $s $d $i $r $z $t $o $m )					#( $q $c $a $c $l $o $d $q $t $y $i $y $c $r $a $v )					#( $d $e $s $m $p $a $n $t $s $e $m $t $d $e $s $t )					#( $i $t $q $e $e $t $r $o $a $b $n $o $a $h $n $a )					#( $d $n $e $c $r $p $o $l $v $n $e $z $s $m $i $m )					#( $p $l $o $r $s $s $i $s $t $t $u $g $c $t $o $g )					#( $b $a $l $v $r $i $d $n $m $o $l $s $b $a $n $v )					#( $o $j $n $a $o $y $l $o $i $f $g $a $e $s $z $a )					#( $n $m $e $l $l $s $e $n $n $p $i $r $m $c $i $n )					#( $l $s $a $l $n $m $u $c $r $l $a $r $m $b $a $m )					#( $p $e $m $h $z $a $r $n $y $e $c $l $p $e $s $r )					#( $i $s $n $o $u $s $t $a $o $s $c $e $i $c $i $o )					#( $r $d $e $a $s $d $o $l $d $l $e $s $r $l $o $m )					#( $p $g $u $r $l $v $o $c $l $s $e $r $b $m $e $m )					#( $s $i $a $s $n $a $p $r $m $u $r $h $t $o $s $c ) ).						words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.	" Didn't return Dictionary "	self assert: found isDictionary. 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	" Return score once all words are verified "	score := self scoreOf: found.	^'3d - 16x16 test: ', score asString, ' points'.	! !----SNAPSHOT----2024-02-12T17:14:18.591-05:00 BoggleTester.image priorSource: 87886!----SNAPSHOT----2024-02-12T17:15:09.309-05:00 BoggleTester.image priorSource: 95376!----QUIT/NOSAVE----2024-02-12T20:23:43.05-05:00 BoggleTester.image priorSource: 95462!----QUIT----2024-02-12T20:25:38.421-05:00 BoggleTester.image priorSource: 95462!----QUIT----2024-02-13T11:45:17.996-05:00 BoggleTester.image priorSource: 95636!!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 2/14/2024 09:05'!validType: found		| t1 t2 t3 |		t1 := found isDictionary.		^t1! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/14/2024 09:06' prior: 33636756!test_1_mass_4x4 				| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_500.txt' asFileReference contents lines.	" NOT testing for points. Looking for run-time errors "	1000 timesRepeat: [		| res |				" Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.			" Should get through this method call without exceptions, and return a Dictionary "		res := Boggle search: board for: words.			self assert: (self validType: res).			]		! !!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 2/14/2024 09:07' prior: 33650308!validType: found		| entry t1 t2 t3 t4 t5 |		t1 := found isDictionary.	t2 := found isEmpty not.				^t1 & t2! !!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 2/14/2024 09:12' prior: 33651668!validType: found		| entry t1 t2 t3 t4 t5 |		found isDictionary ifFalse: [ ^false ].	found isEmpty ifTrue: [ ^false ].		entry := found asArray at: 1.		entry key isString ifFalse: [ ^false ].	entry value isArray ifFalse: [ ^false ].	(entry value at: 1) isPoint ifFalse: [ ^false].			^true! !!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 2/14/2024 09:13' prior: 33651879!validType: found		| entry |		found isDictionary ifFalse: [ ^false ].	found isEmpty ifTrue: [ ^false ].		entry := found asArray at: 1.		entry key isString ifFalse: [ ^false ].	entry value isArray ifFalse: [ ^false ].	(entry value at: 1) isPoint ifFalse: [ ^false].			^true! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/14/2024 09:14' prior: 33642482!test_2a_given_2x2	| board words found score |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return proper Dictionary "	self assert: (self validType: found). 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: 	a (1 point) 	as at (4 points) eat tea sea set (16 points)	east seat (12 points) total = 33 "		" Return score out of 33 "	score := self scoreOf: found.	^'2a - 2x2 test: ', score asString, '/33 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/14/2024 09:14' prior: 33643258!test_2b_given_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return proper Dictionary "	self assert: (self validType: found). 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: (tell me if you find others that i've missed)	a i (2 points) 	as no on so up us vs (14 points) net one pet set son sue ten use (32 points)	ease east even nose oven past save step vast (54 points) event issue noise pause (36 points) 	session (16 points) total = 154 "		" Return score out of 124 "	score := self scoreOf: found.	^'2b - 4x4 test: ', score asString, '/154 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/14/2024 09:14' prior: 33646744!test_3a_small_2x2	| board words found score |	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return proper Dictionary "	self assert: (self validType: found). 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	score := self scoreOf: found.	^'3a - 2x2 test: ', score asString, ' points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/14/2024 09:14' prior: 33646048!test_3b_medium_4x4	| board words found score |	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return proper Dictionary "	self assert: (self validType: found). 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		score := self scoreOf: found.	^'3b - 4x4 test: ', score asString, ' points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/14/2024 09:14' prior: 33647381!test_3c_large_8x8		| board words found score |	board := #( 	#( $o $c $n $e $a $s $r $a ) 					#( $c $r $i $s $h $t $i $r )  					#( $l $l $a $n $n $r $e $n )					#( $g $e $n $s $s $a $q $n )					#( $d $a $m $c $o $b $n $u ) 					#( $n $r $o $o $s $y $e $n )					#( $a $t $s $a $r $s $o $n )					#( $b $e $s $s $n $n $i $s ) ).						words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.	" Didn't return proper Dictionary "	self assert: (self validType: found). 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	" Return score once all words are verified "	score := self scoreOf: found.	^'3c - 8x8 test: ', score asString, ' points'.! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/14/2024 09:14' prior: 33648305!test_3d_mega_16x16	| board words found score |	board := #( 	#( $a $q $o $a $u $s $i $e $a $r $t $u $e $l $r $o ) 					#( $l $n $u $c $r $s $u $r $s $d $i $r $z $t $o $m )					#( $q $c $a $c $l $o $d $q $t $y $i $y $c $r $a $v )					#( $d $e $s $m $p $a $n $t $s $e $m $t $d $e $s $t )					#( $i $t $q $e $e $t $r $o $a $b $n $o $a $h $n $a )					#( $d $n $e $c $r $p $o $l $v $n $e $z $s $m $i $m )					#( $p $l $o $r $s $s $i $s $t $t $u $g $c $t $o $g )					#( $b $a $l $v $r $i $d $n $m $o $l $s $b $a $n $v )					#( $o $j $n $a $o $y $l $o $i $f $g $a $e $s $z $a )					#( $n $m $e $l $l $s $e $n $n $p $i $r $m $c $i $n )					#( $l $s $a $l $n $m $u $c $r $l $a $r $m $b $a $m )					#( $p $e $m $h $z $a $r $n $y $e $c $l $p $e $s $r )					#( $i $s $n $o $u $s $t $a $o $s $c $e $i $c $i $o )					#( $r $d $e $a $s $d $o $l $d $l $e $s $r $l $o $m )					#( $p $g $u $r $l $v $o $c $l $s $e $r $b $m $e $m )					#( $s $i $a $s $n $a $p $r $m $u $r $h $t $o $s $c ) ).						words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.	" Didn't return proper Dictionary "	self assert: (self validType: found). 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	" Return score once all words are verified "	score := self scoreOf: found.	^'3d - 16x16 test: ', score asString, ' points'.	! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'AU 2/14/2024 09:15' prior: 33615919!search: board for: words			" Your code here "			"^Dictionary new"	^Dictionary with: 'seat'->{(2@1).(1@1).(1@2).(2@2)}.													! !!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 2/14/2024 09:27' prior: 33652274!validType: found		| entry_key entry_val |		found isDictionary ifFalse: [ ^false ].	found isEmpty ifTrue: [ ^false ].		entry_key := found keys at: 1.	entry_val := found at: entry_key.		entry_key isString ifFalse: [ ^false ].	entry_val isArray ifFalse: [ ^false ].	(entry_val at: 1) isPoint ifFalse: [ ^false].			^true! !!BoggleTest methodsFor: 'as yet unclassified' stamp: 'AU 2/14/2024 09:27' prior: 33658588!validType: found		| entry_key entry_val |		found isDictionary ifFalse: [ ^false ].	found isEmpty ifTrue: [ ^false ].		entry_key := found keys at: 1.	entry_val := found at: entry_key.		entry_key isString ifFalse: [ ^false ].	entry_val isArray ifFalse: [ ^false ].	(entry_val at: 1) isPoint ifFalse: [ ^false].			^true ! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/14/2024 09:27' prior: 33650458!test_1_mass_4x4 				| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'qbmjoa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_500.txt' asFileReference contents lines.	" NOT testing for points. Looking for run-time errors "	1000 timesRepeat: [		| res |				" Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.			" Should get through this method call without exceptions, and return a Dictionary "		res := Boggle search: board for: words.			self assert: (self validType: res).	]		! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/14/2024 09:28' prior: 33652641!test_2a_given_2x2	| board words found score | 	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return proper Dictionary "	self assert: (self validType: found). 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: 	a (1 point) 	as at (4 points) eat tea sea set (16 points)	east seat (12 points) total = 33 "		" Return score out of 33 "	score := self scoreOf: found.	^'2a - 2x2 test: ', score asString, '/33 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/14/2024 09:28' prior: 33653429!test_2b_given_4x4	| board words found score | 	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_3000.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return proper Dictionary "	self assert: (self validType: found). 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		" words: (tell me if you find others that i've missed)	a i (2 points) 	as no on so up us vs (14 points) net one pet set son sue ten use (32 points)	ease east even nose oven past save step vast (54 points) event issue noise pause (36 points) 	session (16 points) total = 154 "		" Return score out of 124 "	score := self scoreOf: found.	^'2b - 4x4 test: ', score asString, '/154 possible points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/14/2024 09:28' prior: 33654451!test_3a_small_2x2	| board words found score | 	board := #( 	#( $e $a ) 					#( $s $t ) ).	words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return proper Dictionary "	self assert: (self validType: found). 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	score := self scoreOf: found.	^'3a - 2x2 test: ', score asString, ' points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/14/2024 09:28' prior: 33655100!test_3b_medium_4x4	| board words found score | 	board := #( 	#( $i $s $u $o ) 					#( $o $s $v $e ) 					#( $n $e $p $a )					#( $n $t $s $u ) ).	words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.		" Didn't return proper Dictionary "	self assert: (self validType: found). 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).		score := self scoreOf: found.	^'3b - 4x4 test: ', score asString, ' points'.				! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/14/2024 09:28' prior: 33655808!test_3c_large_8x8		| board words found score |	board := #( 	#( $o $c $n $e $a $s $r $a ) 					#( $c $r $i $s $h $t $i $r )  					#( $l $l $a $n $n $r $e $n )					#( $g $e $n $s $s $a $q $n )					#( $d $a $m $c $o $b $n $u ) 					#( $n $r $o $o $s $y $e $n )					#( $a $t $s $a $r $s $o $n )					#( $b $e $s $s $n $n $i $s ) ).						words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words.	" Didn't return proper Dictionary "	self assert: (self validType: found). 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	" Return score once all words are verified "	score := self scoreOf: found. 	^'3c - 8x8 test: ', score asString, ' points'.! !!BoggleTest methodsFor: 'tests' stamp: 'AU 2/14/2024 09:28' prior: 33656744!test_3d_mega_16x16	| board words found score |	board := #( 	#( $a $q $o $a $u $s $i $e $a $r $t $u $e $l $r $o ) 					#( $l $n $u $c $r $s $u $r $s $d $i $r $z $t $o $m )					#( $q $c $a $c $l $o $d $q $t $y $i $y $c $r $a $v )					#( $d $e $s $m $p $a $n $t $s $e $m $t $d $e $s $t )					#( $i $t $q $e $e $t $r $o $a $b $n $o $a $h $n $a )					#( $d $n $e $c $r $p $o $l $v $n $e $z $s $m $i $m )					#( $p $l $o $r $s $s $i $s $t $t $u $g $c $t $o $g )					#( $b $a $l $v $r $i $d $n $m $o $l $s $b $a $n $v )					#( $o $j $n $a $o $y $l $o $i $f $g $a $e $s $z $a )					#( $n $m $e $l $l $s $e $n $n $p $i $r $m $c $i $n )					#( $l $s $a $l $n $m $u $c $r $l $a $r $m $b $a $m )					#( $p $e $m $h $z $a $r $n $y $e $c $l $p $e $s $r )					#( $i $s $n $o $u $s $t $a $o $s $c $e $i $c $i $o )					#( $r $d $e $a $s $d $o $l $d $l $e $s $r $l $o $m )					#( $p $g $u $r $l $v $o $c $l $s $e $r $b $m $e $m )					#( $s $i $a $s $n $a $p $r $m $u $r $h $t $o $s $c ) ).						words := 'word_list_scrabble_2019.txt' asFileReference contents lines.	found := Boggle search: board for: words. 	" Didn't return proper Dictionary "	self assert: (self validType: found). 	" Dictionary contained words that aren't in the list "	self assert: (self words: found legal: words). 	" Coordinates don't match the board "	self assert: (self words: found board: board).	" Return score once all words are verified "	score := self scoreOf: found.	^'3d - 16x16 test: ', score asString, ' points'.	! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'AU 2/14/2024 09:28' prior: 33658353!search: board for: words			" Your code here "			^Dictionary new													! !----SNAPSHOT----2024-02-14T09:29:58.339-05:00 BoggleTester.image priorSource: 95718!----QUIT----2024-02-14T09:30:00.81-05:00 BoggleTester.image priorSource: 111996!----QUIT/NOSAVE----2024-02-15T08:55:43.523-05:00 BoggleTester.image priorSource: 112082!!BoggleTest methodsFor: 'tests' stamp: 'AU 2/15/2024 10:45' prior: 33659429!test_1_mass_4x4 				| dice_arr dice_shuf board words |	dice_arr := #( 'rifobx' 'ifehey' 'denows' 'utoknd' 'hmsrao' 'lupets' 'acitoa' 'ylgkue'						'aaaaaa' 'ehispn' 'vetign' 'baliyt' 'ezavnd' 'ralesc' 'uwilrg' 'pacemd' ).	board := Array new: 4.	words := 'word_list_500.txt' asFileReference contents lines.	" NOT testing for points. Looking for run-time errors "	1000 timesRepeat: [		| res |				" Dice are randomly placed in board, random char chosen from each. "		dice_shuf := dice_arr shuffled collect: [ :e | e atRandom ].		board	at: 1 put: {(dice_shuf at:  1).(dice_shuf at:  2).(dice_shuf at:  3).(dice_shuf at:  4)}.		board	at: 2 put: {(dice_shuf at:  5).(dice_shuf at:  6).(dice_shuf at:  7).(dice_shuf at:  8)}.		board	at: 3 put: {(dice_shuf at:  9).(dice_shuf at: 10).(dice_shuf at: 11).(dice_shuf at: 12)}.		board	at: 4 put: {(dice_shuf at: 13).(dice_shuf at: 14).(dice_shuf at: 15).(dice_shuf at: 16)}.			" Should get through this method call without exceptions, and return a Dictionary "		res := Boggle search: board for: words.			self assert: (self validType: res).	]		! !----QUIT----2024-02-15T10:46:36.551-05:00 BoggleTester.image priorSource: 112082!!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/24/2024 14:43' prior: 33666340!search: board for: words	"board is a static array of arrays whose elements are characters, e.g. #(#($e $a) #($s $t))	words is an array of strings, where each string is a word from the list of legal words e.g. #(‘word1’ ‘word2’ ‘word3’ ... )"			| numRows numColumns row element currCoords prevCoords defaultCoords coordsDist matchFound letterFound coordsOCSizeBefore coordsOC coordsArr resultDict matfalse |		numRows := board size.	numColumns := board first size.	resultDict := Dictionary new.	defaultCoords := 0@0.	coordsDist := 0@0.		"For each word in list of words:"	words do: [:word |		(word size <= (numRows*numColumns)) ifTrue: [			coordsOC := OrderedCollection new. "Reset coordinates array for each word"			prevCoords := 0@0.						  "Reset previous coordinates of matched letter for each word"			matchFound := true.						  "Reset match found for each word"						"For each letter in each word:"			word do: [:letter |								coordsOCSizeBefore := coordsOC size.				letterFound := false.								"Only check for the target letter on the board if it's the first letter of the target word OR the previous letter was found"				(matchFound) ifTrue: [									"Two loops to iterate over each letter in the board:"					"Loop over each row:"					1 to: numRows do: [:yCord |						row := board at: yCord.												"Loop over each element (letter) in row:"						1 to: numColumns do: [:xCord |														"Only continue searching board if letter hasn't been found"							(letterFound = false) ifTrue: [								element := row at: xCord.								currCoords := Point x: yCord y: xCord.																(prevCoords ~= defaultCoords) ifTrue: [									coordsDist := currCoords - prevCoords.									].																(element = letter) ifTrue: [					"If current letter in board = letter in target word"									"If matched letter is the first from the targer word OR letter is not more than 1 block away from previous and letter hasn't already been used"									(prevCoords = defaultCoords) | ((coordsDist x between: -1 and: 1) & (coordsDist y between: -1 and: 1) & ((coordsOC includes: currCoords) = false)) ifTrue: [											coordsOC add: currCoords.											prevCoords := currCoords.											letterFound := 	true.													].									].									].							].						].					"If point hasn't been added to coordsOC after searching whole board (i.e. no match), set matchFound to false"					((coordsOC size) = coordsOCSizeBefore) ifTrue: [ matfalse ].							].				].						(matchFound) ifTrue: [			"If matchFound is still true after iterating through all letters (all letters were found in target word), add to resultDict"				coordsArr := coordsOC asArray.				resultDict add: word->coordsArr.								].			].		].			^resultDict													! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/24/2024 14:44' prior: 33668061!search: board for: words	"board is a static array of arrays whose elements are characters, e.g. #(#($e $a) #($s $t))	words is an array of strings, where each string is a word from the list of legal words e.g. #(‘word1’ ‘word2’ ‘word3’ ... )"			| numRows numColumns row element currCoords prevCoords defaultCoords coordsDist matchFound letterFound coordsOCSizeBefore coordsOC coordsArr resultDict |		numRows := board size.	numColumns := board first size.	resultDict := Dictionary new.	defaultCoords := 0@0.	coordsDist := 0@0.		"For each word in list of words:"	words do: [:word |		(word size <= (numRows*numColumns)) ifTrue: [			coordsOC := OrderedCollection new. "Reset coordinates array for each word"			prevCoords := 0@0.						  "Reset previous coordinates of matched letter for each word"			matchFound := true.						  "Reset match found for each word"						"For each letter in each word:"			word do: [:letter |								coordsOCSizeBefore := coordsOC size.				letterFound := false.								"Only check for the target letter on the board if it's the first letter of the target word OR the previous letter was found"				(matchFound) ifTrue: [									"Two loops to iterate over each letter in the board:"					"Loop over each row:"					1 to: numRows do: [:yCord |						row := board at: yCord.												"Loop over each element (letter) in row:"						1 to: numColumns do: [:xCord |														"Only continue searching board if letter hasn't been found"							(letterFound = false) ifTrue: [								element := row at: xCord.								currCoords := Point x: yCord y: xCord.																(prevCoords ~= defaultCoords) ifTrue: [									coordsDist := currCoords - prevCoords.									].																(element = letter) ifTrue: [					"If current letter in board = letter in target word"									"If matched letter is the first from the targer word OR letter is not more than 1 block away from previous and letter hasn't already been used"									(prevCoords = defaultCoords) | ((coordsDist x between: -1 and: 1) & (coordsDist y between: -1 and: 1) & ((coordsOC includes: currCoords) = false)) ifTrue: [											coordsOC add: currCoords.											prevCoords := currCoords.											letterFound := 	true.													].									].									].							].						].					"If point hasn't been added to coordsOC after searching whole board (i.e. no match), set matchFound to false"					((coordsOC size) = coordsOCSizeBefore) ifTrue: [ matchFound := 	false ].							].				].						(matchFound) ifTrue: [			"If matchFound is still true after iterating through all letters (all letters were found in target word), add to resultDict"				coordsArr := coordsOC asArray.				resultDict add: word->coordsArr.								].			].		].			^resultDict													! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/24/2024 23:17' prior: 33670981!search: board for: words	| trie result |		trie := Dictionary new.	words do: [ :word | 		| currTrie |				currTrie := trie.		word do: [ :char | 			currTrie := currTrie				at: char				ifAbsentput: [ Dictionary new ]			].		].! !!ManifestCPS506 commentStamp: '<historical>' prior: 0!Please describe the package using the class comment of the included manifest class. The manifest class also includes other additional metadata for the package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!ManifestCPS506 class methodsFor: 'code-critics' stamp: 'DannyVo 2/24/2024 23:18'!ruleSentNotImplementedRuleV1FalsePositive	^ #()! !!ManifestCPS506 class methodsFor: 'code-critics' stamp: 'DannyVo 2/24/2024 23:18' prior: 33674542!ruleSentNotImplementedRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#'Boggle class' #search:for: #true)) #'2024-02-24T23:18:13.515-05:00') )! !Smalltalk globals removeClassNamed: #AnObsoleteManifestCPS506!!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/24/2024 23:20' prior: 33673904!search: board for: words	| trie result |		trie := Dictionary new.	words do: [ :word | 		| currTrie |				currTrie := trie.		word do: [ :char | 			currTrie := currTrie				at: char				ifAbsentput: [ Dictionary new ]			].			currTrie at: #wordend put: word.		].	! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/24/2024 23:26' prior: 33675004!search: board for: words	| trie result |		trie := Dictionary new.	words do: [ :word | 		| currTrie |				currTrie := trie.		word do: [ :char | 			currTrie := (currTrie at: char ifAbsentPut: [ Dictionary new ])			].			currTrie at: #wordend put: word.		].		result := Dictionary new.	1 to: board size do: [ :y |		1 to: board first size do: [:x | 			self boardDFS: board.			].		].! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 00:59'!dfsWithGrid: grid trie: trie y: y x: x path: path result: result    | char next_trie |    "Return early location outside grid"    (y between: 1 and: grid size) ifFalse: [ ^nil ].    (x between: 1 and: grid size) ifFalse: [ ^nil ].    "Return early if location already visited"    (path includes: y @ x) ifTrue: [ ^nil ].    "Return early if letter not in trie"    char := (grid at: y) at: x.    (trie includesKey: char) ifFalse: [ ^nil ].    "Add location to paths"    path addLast: y @ x.    next_trie := trie at: char.    "If this is a word, add to result"    (next_trie includesKey: #wordend) ifTrue: [        result at: (next_trie at: #wordend) put: (Array newFrom: path).    ].    "Recurse into surrounding cells"    y-1 to: y+1 do: [ :dy |        x-1 to: x+1 do: [ :dx |            self                dfsWithGrid: grid                trie: next_trie                y: dy x: dx                path: path                result: result        ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 01:00' prior: 33675378!search: grid for: words    | trie result |    "First, make the trie containing all words"    trie := Dictionary new.    words do: [ :word |        | current_trie |        current_trie := trie.        word do: [ :char |            current_trie := current_trie                at: char                ifAbsentPut: [ Dictionary new ]        ].        current_trie at: #wordend put: word.    ].    "Next, recursively DFS starting from each cell"    result := Dictionary new.    1 to: grid size do: [ :y |        1 to: grid size do: [ :x |            self                dfsWithGrid: grid                trie: trie                y: y x: x                path: OrderedCollection new                result: result        ].    ].    ^result! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 01:19' prior: 33677002!search: board for: words    |  result |    "First, make the trie containing all words"        words do: [ :word |        | current_trie |        current_trie := Dictionary new.        word do: [ :char |            current_trie := current_trie                at: char                ifAbsentPut: [ Dictionary new ]        ].        current_trie at: #wordend put: word.    ].    "Next, recursively DFS starting from each cell"    result := Dictionary new.    1 to: board size do: [ :y |        1 to: board size do: [ :x |            self                dfsWithGrid: board                trie: Dictionary new                y: y x: x                path: OrderedCollection new                result: result        ].    ].    ^result! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 01:59' prior: 33677866!search: board for: words    | trie result |    "First, make the trie containing all words"    trie := Dictionary new.    words do: [ :word |        | current_trie |        current_trie := trie.        word do: [ :char |            current_trie := current_trie                at: char                ifAbsentPut: [ Dictionary new ]        ].        current_trie at: #wordend put: word.    ].    "Next, recursively DFS starting from each cell"    result := Dictionary new.    1 to: board size do: [ :y |        1 to: board size do: [ :x |            self                dfsWithGrid: board                trie: trie                y: y x: x                path: OrderedCollection new                result: result        ].    ].    ^result! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 03:38' prior: 33678727!search: board for: words	"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end':'end'}}}}}								 1.1 - call DFS on every cell on board then return result after nested loop										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result				RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if coordinates is already visited in visitedpath					3. if letter is not in trie									otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"						   | trie result currDict|	"1.0 TRIE CREATION"	trie = Dictionary new.	words do: [ :word | 		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict := currDict at: 'end' put: '*'.		].      "1.1 RUN DFS ON EACH CELL"    result := Dictionary new.    1 to: board size do: [ :y |        1 to: board first size do: [ :x |            self                dfsWithGrid: board                trie: trie                y: y x: x                path: OrderedCollection new                result: result        ].    ].    ^result! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 03:38' prior: 33679595!search: board for: words	"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end':'end'}}}}}								 1.1 - call DFS on every cell on board then return result after nested loop										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result				RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if coordinates is already visited in visitedpath					3. if letter is not in trie									otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"						   | trie result currDict|	"1.0 TRIE CREATION"	trie := Dictionary new.	words do: [ :word | 		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict := currDict at: 'end' put: '*'.		].      "1.1 RUN DFS ON EACH CELL"    result := Dictionary new.    1 to: board size do: [ :y |        1 to: board first size do: [ :x |            self                dfsWithGrid: board                trie: trie                y: y x: x                path: OrderedCollection new                result: result        ].    ].    ^result! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 03:39' prior: 33675858!dfsWithGrid: grid trie: trie y: y x: x path: path result: result    | char next_trie |    "Return early location outside grid"    (y between: 1 and: grid size) ifFalse: [ ^nil ].    (x between: 1 and: grid size) ifFalse: [ ^nil ].    "Return early if location already visited"    (path includes: y @ x) ifTrue: [ ^nil ].    "Return early if letter not in trie"    char := (grid at: y) at: x.    (trie includesKey: char) ifFalse: [ ^nil ].    "Add location to paths"    path addLast: y @ x.    next_trie := trie at: char.    "If this is a word, add to result"    (next_trie includesKey: 'end') ifTrue: [        result at: (next_trie at: 'end') put: (Array newFrom: path).    ].    "Recurse into surrounding cells"    y-1 to: y+1 do: [ :dy |        x-1 to: x+1 do: [ :dx |            self                dfsWithGrid: grid                trie: next_trie                y: dy x: dx                path: path                result: result        ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 03:41' prior: 33682694!search: board for: words	"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end':'end'}}}}}								 1.1 - call DFS on every cell on board then return result after nested loop										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result				RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if coordinates is already visited in visitedpath					3. if letter is not in trie									otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"						   | trie result currDict|	"1.0 TRIE CREATION"	trie := Dictionary new.	words do: [ :word | 		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict := currDict at: 'end' put: '*'.		].      "1.1 RUN DFS ON EACH CELL"    result := Dictionary new.    1 to: board size do: [ :y |        1 to: board size do: [ :x |            self                dfsWithGrid: board                trie: trie                y: y x: x                path: OrderedCollection new                result: result        ].    ].    ^result! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 03:41' prior: 33685794!dfsWithGrid: board trie: trie y: y x: x path: path result: result    | char next_trie |    "Return early location outside board"    (y between: 1 and: board size) ifFalse: [ ^nil ].    (x between: 1 and: board size) ifFalse: [ ^nil ].    "Return early if location already visited"    (path includes: y @ x) ifTrue: [ ^nil ].    "Return early if letter not in trie"    char := (board at: y) at: x.    (trie includesKey: char) ifFalse: [ ^nil ].    "Add location to paths"    path addLast: y @ x.    next_trie := trie at: char.    "If this is a word, add to result"    (next_trie includesKey: 'end') ifTrue: [        result at: (next_trie at: 'end') put: (Array newFrom: path).    ].    "Recurse into surrounding cells"    y-1 to: y+1 do: [ :dy |        x-1 to: x+1 do: [ :dx |            self                dfsWithboard: board                trie: next_trie                y: dy x: dx                path: path                result: result        ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 03:42'!dfs: board trie: trie y: y x: x path: path result: result    | char next_trie |    "Return early location outside board"    (y between: 1 and: board size) ifFalse: [ ^nil ].    (x between: 1 and: board size) ifFalse: [ ^nil ].    "Return early if location already visited"    (path includes: y @ x) ifTrue: [ ^nil ].    "Return early if letter not in trie"    char := (board at: y) at: x.    (trie includesKey: char) ifFalse: [ ^nil ].    "Add location to paths"    path addLast: y @ x.    next_trie := trie at: char.    "If this is a word, add to result"    (next_trie includesKey: 'end') ifTrue: [        result at: (next_trie at: 'end') put: (Array newFrom: path).    ].    "Recurse into surrounding cells"    y-1 to: y+1 do: [ :dy |        x-1 to: x+1 do: [ :dx |            self                dfs: board                trie: next_trie                y: dy x: dx                path: path                result: result        ].    ].    "Remove location from paths"    path removeLast! !Boggle class removeSelector: #dfsWithGrid:trie:y:x:path:result:!!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 03:42' prior: 33686932!search: board for: words	"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end':'end'}}}}}								 1.1 - call DFS on every cell on board then return result after nested loop										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result				RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if coordinates is already visited in visitedpath					3. if letter is not in trie									otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"						   | trie result currDict|	"1.0 TRIE CREATION"	trie := Dictionary new.	words do: [ :word | 		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict := currDict at: 'end' put: '*'.		].      "1.1 RUN DFS ON EACH CELL"    result := Dictionary new.    1 to: board size do: [ :y |        1 to: board size do: [ :x |            self                dfs: board                trie: trie                y: y x: x                path: OrderedCollection new                result: result        ].    ].    ^result! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 03:44' prior: 33692349!search: board for: words	"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end':'end'}}}}}								 1.1 - call DFS on every cell on board then return result after nested loop										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result				RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if coordinates is already visited in visitedpath					3. if letter is not in trie									otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"						   | trie result |	"1.0 TRIE CREATION"	trie := Dictionary new.	words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict := currDict at: 'end' put: '*'.		].      "1.1 RUN DFS ON EACH CELL"    result := Dictionary new.    1 to: board size do: [ :y |        1 to: board size do: [ :x |            self                dfs: board                trie: trie                y: y x: x                path: OrderedCollection new                result: result        ].    ].    ^result! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 03:44' prior: 33695435!search: board for: words	"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end':'end'}}}}}								 1.1 - call DFS on every cell on board then return result after nested loop										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result				RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if coordinates is already visited in visitedpath					3. if letter is not in trie									otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"						   | trie result |	"1.0 TRIE CREATION"	trie := Dictionary new.	words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict := currDict at: 'end' put: 'end'.		].      "1.1 RUN DFS ON EACH CELL"    result := Dictionary new.    1 to: board size do: [ :y |        1 to: board size do: [ :x |            self                dfs: board                trie: trie                y: y x: x                path: OrderedCollection new                result: result        ].    ].    ^result! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 03:46' prior: 33698526!search: board for: words	"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end':'end'}}}}}								 1.1 - call DFS on every cell on board then return result after nested loop										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result				RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if coordinates is already visited in visitedpath					3. if letter is not in trie									otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"						   | trie result |	"1.0 TRIE CREATION"	trie := Dictionary new.	words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict at: 'end' put: 'end'.		].      "1.1 RUN DFS ON EACH CELL"    result := Dictionary new.    1 to: board size do: [ :y |        1 to: board size do: [ :x |            self                dfs: board                trie: trie                y: y x: x                path: OrderedCollection new                result: result        ].    ].    ^result! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 03:47' prior: 33701619!search: board for: words					   | trie result |	"1.0 TRIE CREATION"	trie := Dictionary new.	words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict at: 'end' put: 'end'.		].      "1.1 RUN DFS ON EACH CELL"    result := Dictionary new.    1 to: board size do: [ :y |        1 to: board size do: [ :x |            self                dfs: board                trie: trie                y: y x: x                path: OrderedCollection new                result: result        ].    ].    ^result! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 03:47' prior: 33704700!search: board for: words					   | trie result |	"1.0 TRIE CREATION"	trie := Dictionary new.	words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict at: 'end' put: word.		].      "1.1 RUN DFS ON EACH CELL"    result := Dictionary new.    1 to: board size do: [ :y |        1 to: board size do: [ :x |            self                dfs: board                trie: trie                y: y x: x                path: OrderedCollection new                result: result        ].    ].    ^result! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 03:49' prior: 33705423!search: board for: words		"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end':'end'}}}}}								 1.1 - call DFS on every cell on board then return result after nested loop										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result				RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if coordinates is already visited in visitedpath					3. if letter is not in trie									otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"				   | trie result |	"1.0 TRIE CREATION"	trie := Dictionary new.	words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict at: 'end' put: '*'.		].      "1.1 RUN DFS ON EACH CELL"    result := Dictionary new.    1 to: board size do: [ :y |        1 to: board size do: [ :x |            self                dfs: board                trie: trie                y: y x: x                path: OrderedCollection new                result: result        ].    ].    ^result! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 03:49' prior: 33706145!search: board for: words		"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end':'end'}}}}}								 1.1 - call DFS on every cell on board then return result after nested loop										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result				RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if coordinates is already visited in visitedpath					3. if letter is not in trie									otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"				   | trie result |	"1.0 TRIE CREATION"	trie := Dictionary new.	words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict at: 'end' put: Object.		].      "1.1 RUN DFS ON EACH CELL"    result := Dictionary new.    1 to: board size do: [ :y |        1 to: board size do: [ :x |            self                dfs: board                trie: trie                y: y x: x                path: OrderedCollection new                result: result        ].    ].    ^result! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 03:50' prior: 33709222!search: board for: words		"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end':'end'}}}}}								 1.1 - call DFS on every cell on board then return result after nested loop										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result				RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if coordinates is already visited in visitedpath					3. if letter is not in trie									otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"				   | trie result |	"1.0 TRIE CREATION"	trie := Dictionary new.	words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict at: 'end' put: word.		].      "1.1 RUN DFS ON EACH CELL"    result := Dictionary new.    1 to: board size do: [ :y |        1 to: board size do: [ :x |            self                dfs: board                trie: trie                y: y x: x                path: OrderedCollection new                result: result        ].    ].    ^result! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 03:50' prior: 33712302!search: board for: words		"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end': meow}}}}}								 1.1 - call DFS on every cell on board then return result after nested loop										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result				RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if coordinates is already visited in visitedpath					3. if letter is not in trie									otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"				   | trie result |	"1.0 TRIE CREATION"	trie := Dictionary new.	words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict at: 'end' put: word.		].      "1.1 RUN DFS ON EACH CELL"    result := Dictionary new.    1 to: board size do: [ :y |        1 to: board size do: [ :x |            self                dfs: board                trie: trie                y: y x: x                path: OrderedCollection new                result: result        ].    ].    ^result! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 03:57' prior: 33715380!search: board for: words		"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end': meow}}}}}								 1.1 - call DFS on every cell on board then return result after nested loop										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result				RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if coordinates is already visited in visitedpath					3. if letter is not in trie									otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"				   | trie resultDict |	"1.0 TRIE CREATION"	trie := Dictionary new.	resultDict := Dictionary new.		words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict at: 'end' put: word.		].      "1.1 RUN DFS ON EACH CELL"    1 to: board size do: [ :y |        1 to: board first size do: [ :x |        		self                dfs: board trie: trie y: y x: x path: OrderedCollection new result: resultDict        ].    ].    ^resultDict! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:01' prior: 33691155!dfs: board trie: trie y: y x: x path: path result: result    | char next_trie |        "Return early if location already visited"    (path includes: y @ x) ifTrue: [ ^nil ].    "Return early if letter not in trie"    char := (board at: y) at: x.    (trie includesKey: char) ifFalse: [ ^nil ].    "Add location to paths"    path addLast: y @ x.    next_trie := trie at: char.    "If this is a word, add to result"    (next_trie includesKey: 'end') ifTrue: [        result at: (next_trie at: 'end') put: (Array newFrom: path).    ].    "Recurse into surrounding cells"    y-1 to: y+1 do: [ :dy |        x-1 to: x+1 do: [ :dx |            self                dfs: board                trie: next_trie                y: dy x: dx                path: path                result: result        ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:01' prior: 33718458!search: board for: words		"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end': meow}}}}}								 1.1 - Loop through and call DFS on each cell, it will iterate through each letter, and check potential paths					for each letter recursively and whenever a path matches a word in the TRIE (if 'end' key exists -- meaning 					there is key and value in nextTrie/dict), add it's respective path to resultDict!!!!				After loop return resultDict										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result				RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if coordinates is already visited in visitedpath					3. if letter is not in trie									otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"				   | trie resultDict |	"1.0 TRIE CREATION"	trie := Dictionary new.	resultDict := Dictionary new.		words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict at: 'end' put: word.		].      "1.1 RUN DFS ON EACH CELL"    1 to: board size do: [ :y |        1 to: board first size do: [ :x |        		self                dfs: board trie: trie y: y x: x path: OrderedCollection new result: resultDict        ].    ].    ^resultDict! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:16'!dfs: board trie: trie row: y col: x path: path result: result    | char next_trie |        "Return early if location already visited"    (path includes: y @ x) ifTrue: [ ^nil ].    "Return early if letter not in trie"    char := (board at: y) at: x.    (trie includesKey: char) ifFalse: [ ^nil ].    "Add location to paths"    path addLast: y @ x.    next_trie := trie at: char.    "If this is a word, add to result"    (next_trie includesKey: 'end') ifTrue: [        result at: (next_trie at: 'end') put: (Array newFrom: path).    ].    "Recurse into surrounding cells"    y-1 to: y+1 do: [ :dy |        x-1 to: x+1 do: [ :dx |            self                dfs: board                trie: next_trie                y: dy x: dx                path: path                result: result        ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:16' prior: 33722474!search: board for: words		"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end': meow}}}}}								 1.1 - Loop through and call DFS on each cell, it will iterate through each letter, and check potential paths					for each letter recursively and whenever a path matches a word in the TRIE (if 'end' key exists -- meaning 					there is key and value in nextTrie/dict), add it's respective path to resultDict!!!!				After loop return resultDict										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result				RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if coordinates is already visited in visitedpath					3. if letter is not in trie									otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"				   | trie resultDict |	"1.0 TRIE CREATION"	trie := Dictionary new.	resultDict := Dictionary new.		words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict at: 'end' put: word.		].      "1.1 RUN DFS ON EACH CELL"    1 to: board size do: [ :y |        1 to: board first size do: [ :x |        		self                dfs: board trie: trie row: y col: x path: OrderedCollection new result: resultDict        ].    ].    ^resultDict! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:16' prior: 33721491!dfs: board trie: trie y: y x: x path: path result: result    | char next_trie |        "Return early if location already visited"    (path includes: y @ x) ifTrue: [ ^nil ].    "Return early if letter not in trie"    char := (board at: y) at: x.    (trie includesKey: char) ifFalse: [ ^nil ].    "Add location to paths"    path addLast: y @ x.    next_trie := trie at: char.    "If this is a word, add to result"    (next_trie includesKey: 'end') ifTrue: [        result at: (next_trie at: 'end') put: (Array newFrom: path).    ].    "Recurse into surrounding cells"    y-1 to: y+1 do: [ :dy |        x-1 to: x+1 do: [ :dx |            self                dfs: board                trie: next_trie                row: dy col: dx                path: path                result: result        ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:16' prior: 33725760!dfs: board trie: trie row: y col: x path: path result: result    | char next_trie |        "Return early if location already visited"    (path includes: y @ x) ifTrue: [ ^nil ].    "Return early if letter not in trie"    char := (board at: y) at: x.    (trie includesKey: char) ifFalse: [ ^nil ].    "Add location to paths"    path addLast: y @ x.    next_trie := trie at: char.    "If this is a word, add to result"    (next_trie includesKey: 'end') ifTrue: [        result at: (next_trie at: 'end') put: (Array newFrom: path).    ].    "Recurse into surrounding cells"    y-1 to: y+1 do: [ :dy |        x-1 to: x+1 do: [ :dx |            self                dfs: board                trie: next_trie                row: dy col: dx                path: path                result: result        ].    ].    "Remove location from paths"    path removeLast! !Boggle class removeSelector: #dfs:trie:y:x:path:result:!!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:16' prior: 33726747!search: board for: words		"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end': meow}}}}}								 1.1 - Loop through and call DFS on each cell, it will iterate through each letter, and check potential paths					for each letter recursively and whenever a path matches a word in the TRIE (if 'end' key exists -- meaning 					there is key and value in nextTrie/dict), add it's respective path to resultDict!!!!				After loop return resultDict										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result			2.1 - RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if letter is not in trie 					3. if coordinates is already visited in visitedpath								2.2 -	otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"				   | trie resultDict |	"1.0 TRIE CREATION"	trie := Dictionary new.	resultDict := Dictionary new.		words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict at: 'end' put: word.		].      "1.1 RUN DFS ON EACH CELL"    1 to: board size do: [ :row |        1 to: board first size do: [ :col |        		self                dfs: board trie: trie row: row col: col path: OrderedCollection new result: resultDict        ].    ].    ^resultDict! !!Boggle class methodsFor: 'nil' stamp: 'DannyVo 2/25/2024 04:18' prior: 33731040!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size) | 	(col between: 1 and: board size | 	(trie includesKey: ((board at: row) at: col))) ifFalse: [ ^nil ]).	(path includes: row @ col) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :dy |       col-1 to: col+1 do: [ :dx |           self               dfs: board               trie: nextTrie               y: dy x: dx               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'nil' stamp: 'DannyVo 2/25/2024 04:19' prior: 33735398!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size) | 	(col between: 1 and: board size | 	(trie includesKey: ((board at: row) at: col))) ifFalse: [ ^nil ]).	(path includes: row @ col) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:19' prior: 33736380!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size) | 	(col between: 1 and: board size | 	(trie includesKey: ((board at: row) at: col))) ifFalse: [ ^nil ]).	(path includes: row @ col) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:22' prior: 33737378!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size) & 	(col between: 1 and: board size & 	(trie includesKey: ((board at: row) at: col))) ifFalse: [ ^nil ]).	(path includes: row @ col) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:24' prior: 33738376!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size) | 	(col between: 1 and: board size | 	(trie includesKey: ((board at: row) at: col)))) ifFalse: [ ^nil ].	(path includes: row @ col) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:24' prior: 33739374!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size) & 	(col between: 1 and: board size &	(trie includesKey: ((board at: row) at: col)))) ifFalse: [ ^nil ].	(path includes: row @ col) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:26' prior: 33740372!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size) & 	(col between: 1 and: board size) &	(trie includesKey: ((board at: row) at: col))) ifFalse: [ ^nil ].	(path includes: row @ col) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:26' prior: 33741369!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size) & 	(col between: 1 and: board size) &	(trie includesKey: ((board at: row) at: col))) ifFalse: [ ^nil ].	(path includes: row @ col) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:27' prior: 33742366!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size) 	& (col between: 1 and: board size) 	& (trie includesKey: ((board at: row) at: col))) ifFalse: [ ^nil ].		(path includes: row @ col) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:28' prior: 33743363!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size) 	& (col between: 1 and: board first size) 	& (trie includesKey: ((board at: row) at: col))) ifFalse: [ ^nil ].		(path includes: row @ col) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:29' prior: 33744363!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ( (row between: 1 and: board size) 	& (col between: 1 and: board first size) 	& (trie includesKey: ((board at: row) at: col))) ifFalse: [ ^nil ].		(path includes: row @ col) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:29' prior: 33745369!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ( (row between: 1 and: board size) 	& (col between: 1 and: board size) 	& (trie includesKey: ((board at: row) at: col))) ifFalse: [ ^nil ].		(path includes: row @ col) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:31' prior: 33746376!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ( (row between: 1 and: board size) 	| (col between: 1 and: board size) 	& (trie includesKey: ((board at: row) at: col))) ifFalse: [ ^nil ].		(path includes: row @ col) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:34' prior: 33747377!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ( (row between: 1 and: board size) 	| (col between: 1 and: board size) 	& (trie includesKey: ((board at: col) at: row))) ifFalse: [ ^nil ].		(path includes: col @ row) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:35' prior: 33748378!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ( (row between: 1 and: board size) 	& (col between: 1 and: board size) 	& (trie includesKey: ((board at: col) at: row))) ifFalse: [ ^nil ].		(path includes: col @ row) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:36' prior: 33749379!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ( (row between: 1 and: board size) 	& (col between: 1 and: board size) 	| (trie includesKey: ((board at: col) at: row))) ifFalse: [ ^nil ].		(path includes: col @ row) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:36' prior: 33750380!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ( (row between: 1 and: board size) 	& (col between: 1 and: board first size) 	| (trie includesKey: ((board at: col) at: row))) ifFalse: [ ^nil ].		(path includes: col @ row) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:37' prior: 33751381!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ( (row between: 1 and: board first size) 	& (col between: 1 and: board size) 	| (trie includesKey: ((board at: col) at: row))) ifFalse: [ ^nil ].		(path includes: col @ row) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:37' prior: 33752388!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ( (row between: 1 and: board size) 	& (col between: 1 and: board first size) 	| (trie includesKey: ((board at: col) at: row))) ifFalse: [ ^nil ].		(path includes: col @ row) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:38' prior: 33753395!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ( ((row between: 1 and: board size) 	& (col between: 1 and: board first size)) 	| (trie includesKey: ((board at: col) at: row))) ifFalse: [ ^nil ].		(path includes: col @ row) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:40' prior: 33754402!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ( ((row between: 1 and: board size) 	and: [(col between: 1 and: board first size)]) 	or: [(trie includesKey: ((board at: col) at: row))]) ifFalse: [ ^nil ].		(path includes: col @ row) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:41' prior: 33755411!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   (row between: 1 and: board size) ifFalse: [ ^nil ].	(col between: 1 and: board first size) ifFalse: [ ^nil ].	(trie includesKey: ((board at: col) at: row)) ifFalse: [ ^nil ].		(path includes: col @ row) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:42' prior: 33756429!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie letter |	letter := (board at: col) at: row.   "2.1 CONDITIONAL BASE CASE STATEMENTS"   (row between: 1 and: board size) ifFalse: [ ^nil ].	(col between: 1 and: board first size) ifFalse: [ ^nil ].	(trie includesKey: letter) ifFalse: [ ^nil ].	(path includes: col @ row) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:46' prior: 33757465!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie letter |	letter := (board at: row) at: col.   "2.1 CONDITIONAL BASE CASE STATEMENTS"   (row between: 1 and: board size) ifFalse: [ ^nil ].	(col between: 1 and: board first size) ifFalse: [ ^nil ].	(trie includesKey: letter) ifFalse: [ ^nil ].	(path includes: row @ row) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:47' prior: 33758523!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie letter |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   (row between: 1 and: board size) ifFalse: [ ^nil ].	(col between: 1 and: board first size) ifFalse: [ ^nil ].	letter := (board at: row) at: col.	(trie includesKey: letter) ifFalse: [ ^nil ].	(path includes: row @ row) ifTrue: [ ^nil ].   "2.2"   path addLast: (row@col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:48' prior: 33759581!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie letter |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   (row between: 1 and: board size) ifFalse: [ ^nil ].	(col between: 1 and: board first size) ifFalse: [ ^nil ].	letter := (board at: row) at: col.	(trie includesKey: letter) ifFalse: [ ^nil ].	(path includes: row @ row) ifTrue: [ ^nil ].   "2.2"   path addLast: (row @ col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:49' prior: 33760639!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie letter |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   (row between: 1 and: board size) ifFalse: [ ^nil ].	(col between: 1 and: board size) ifFalse: [ ^nil ].	letter := (board at: row) at: col.	(trie includesKey: letter) ifFalse: [ ^nil ].	(path includes: row @ row) ifTrue: [ ^nil ].   "2.2"   path addLast: (row @ col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:50' prior: 33761699!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie letter |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   (row between: 1 and: board size) ifFalse: [ ^nil ].	(col between: 1 and: board size) ifFalse: [ ^nil ].	letter := (board at: row) at: col.	(trie includesKey: letter) ifFalse: [ ^nil ].	(path includes: row @ col) ifTrue: [ ^nil ].   "2.2"   path addLast: (row @ col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:52' prior: 33762753!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size)	and: [(col between: 1 and: board size)]) ifFalse: [ ^nil ].	(trie includesKey: ((board at: row) at: col)) ifFalse: [ ^nil ].	(path includes: row @ col) ifTrue: [ ^nil ].   "2.2"   path addLast: (row @ col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:53' prior: 33763807!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   (((row between: 1 and: board size)	and: [(col between: 1 and: board size)]) 	and: [(path includes: row @ col)]) ifFalse: [ ^nil ].		(trie includesKey: ((board at: row) at: col)) ifFalse: [ ^nil ].	   "2.2"   path addLast: (row @ col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:55' prior: 33764826!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size) 		and: [(col between: 1 and: board size) 		and: [(path includes: row @ col)]]) 		ifFalse: [ ^nil ].		(trie includesKey: ((board at: row) at: col)) ifFalse: [ ^nil ].	   "2.2"   path addLast: (row @ col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 04:56' prior: 33765841!dfs: board trie: trie row: row col: col path: path result: result	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size) 		and: [(col between: 1 and: board size) 		or: [(path includes: row @ col)]]) 		ifFalse: [ ^nil ].		(trie includesKey: ((board at: row) at: col)) ifFalse: [ ^nil ].	   "2.2"   path addLast: (row @ col).   nextTrie := trie at: ((board at: row) at: col).   "If this is a word, add to result"   (nextTrie includesKey: 'end') ifTrue: [       result at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               result: result       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 05:01'!dfs: board trie: trie row: row col: col path: path resultDict: resultDict	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size)		and: [(col between: 1 and: board size)]) ifFalse: [ ^nil ].	(trie includesKey: ((board at: row) at: col)) ifFalse: [ ^nil ].	(path includes: row @ col) ifTrue: [ ^nil ].   "2.2"   path addLast: (row @ col).   nextTrie := trie at: ((board at: row) at: col).      (nextTrie includesKey: 'end') ifTrue: [		"if end of word, then add to resultDictDict:			KEY (word--which is value of 'end' key)			VALUE (path array)"       resultDict at: (nextTrie at: 'end') put: (Array newFrom: path).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :r |       col-1 to: col+1 do: [ :c |           self               dfs: board               trie: nextTrie               row: r col: c               path: path               resultDict: resultDict       ].    ].    "Remove location from paths"    path removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 05:01' prior: 33732089!search: board for: words		"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end': meow}}}}}								 1.1 - Loop through and call DFS on each cell, it will iterate through each letter, and check potential paths					for each letter recursively and whenever a path matches a word in the TRIE (if 'end' key exists -- meaning 					there is key and value in nextTrie/dict), add it's respective path to resultDict!!!!				After loop return resultDict										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result			2.1 - RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if letter is not in trie 					3. if coordinates is already visited in visitedpath								2.2 -	otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"				   | trie resultDict |	"1.0 TRIE CREATION"	trie := Dictionary new.	resultDict := Dictionary new.		words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].				currDict at: 'end' put: word.		].      "1.1 RUN DFS ON EACH CELL"    1 to: board size do: [ :row |        1 to: board first size do: [ :col |        		self                dfs: board trie: trie row: row col: col path: OrderedCollection new resultDict: resultDict        ].    ].    ^resultDict! !Boggle class removeSelector: #dfs:trie:row:col:path:result:!!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 05:03'!dfs: board trie: trie row: row col: col visitedPath: visitedPath resultDict: resultDict	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size)		and: [(col between: 1 and: board size)]) ifFalse: [ ^nil ].	(trie includesKey: ((board at: row) at: col)) ifFalse: [ ^nil ].	(visitedPath includes: row @ col) ifTrue: [ ^nil ].   "2.2"   visitedPath addLast: (row @ col).   nextTrie := trie at: ((board at: row) at: col).      (nextTrie includesKey: 'end') ifTrue: [		"if end of word, then add to resultDictDict:			KEY (word--which is value of 'end' key)			VALUE (visitedPath array)"       resultDict at: (nextTrie at: 'end') put: (Array newFrom: visitedPath).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :adjRow |       col-1 to: col+1 do: [ :adjCol |           self               dfs: board               trie: nextTrie               row: adjRow col: adjCol               visitedPath: visitedPath               resultDict: resultDict       ].    ].    "Remove location from visitedPaths"    visitedPath removeLast! !Boggle class removeSelector: #dfs:trie:row:col:path:resultDict:!!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 05:04' prior: 33768981!search: board for: words		"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end': meow}}}}}								 1.1 - Loop through and call DFS on each cell, it will iterate through each letter, and check potential paths					for each letter recursively and whenever a path matches a word in the TRIE (if 'end' key exists -- meaning 					there is key and value in nextTrie/dict), add it's respective path to resultDict!!!!				After loop return resultDict										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result			2.1 - RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if letter is not in trie 					3. if coordinates is already visited in visitedpath								2.2 -	otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"				   | trie resultDict |	"1.0 TRIE CREATION"	trie := Dictionary new.	resultDict := Dictionary new.		words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].		currDict at: 'end' put: word.		].      "1.1 RUN DFS ON EACH CELL"    1 to: board size do: [ :row |        1 to: board first size do: [ :col |        		self                dfs: board 					trie: trie 					row: row 					col: col 					visitedPath: OrderedCollection new 					resultDict: resultDict        ].    ].    ^resultDict! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 05:04' prior: 33772356!dfs: board trie: trie row: row col: col visitedPath: visitedPath resultDict: resultDict	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size)		and: [(col between: 1 and: board size)]) ifFalse: [ ^nil ].	(trie includesKey: ((board at: row) at: col)) ifFalse: [ ^nil ].	(visitedPath includes: row @ col) ifTrue: [ ^nil ].   "2.2"   visitedPath addLast: (row @ col).   nextTrie := trie at: ((board at: row) at: col).      (nextTrie includesKey: 'end') ifTrue: [		"if end of word, then add to resultDictDict:			KEY (word--which is value of 'end' key)			VALUE (visitedPath array)"       resultDict at: (nextTrie at: 'end') put: (Array newFrom: visitedPath).   ].   "Recurse into surrounding cells"   row-1 to: row+1 do: [ :adjRow |       col-1 to: col+1 do: [ :adjCol |           self               dfs: board               trie: nextTrie               row: adjRow 					col: adjCol               visitedPath: visitedPath               resultDict: resultDict       ].    ].    "Remove location from visitedPaths"    visitedPath removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 05:05' prior: 33776994!dfs: board trie: trie row: row col: col visitedPath: visitedPath resultDict: resultDict	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size)		and: [(col between: 1 and: board size)]) ifFalse: [ ^nil ].	(trie includesKey: ((board at: row) at: col)) ifFalse: [ ^nil ].	(visitedPath includes: row @ col) ifTrue: [ ^nil ].   "2.2"   visitedPath addLast: (row @ col).   nextTrie := trie at: ((board at: row) at: col).      (nextTrie includesKey: 'end') ifTrue: [		"if end of word, then add to resultDictDict:			KEY (word--which is value of 'end' key)			VALUE (visitedPath array)"       resultDict at: (nextTrie at: 'end') put: (Array newFrom: visitedPath).   ].   "DFS ON ADJACENT CELLS"   row-1 to: row+1 do: [ :adjRow |       col-1 to: col+1 do: [ :adjCol |           self               dfs: board               trie: nextTrie               row: adjRow 					col: adjCol               visitedPath: visitedPath               resultDict: resultDict       ].    ].    visitedPath removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 05:05' prior: 33778209!dfs: board trie: trie row: row col: col visitedPath: visitedPath resultDict: resultDict	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size)		and: [(col between: 1 and: board size)]) ifFalse: [ ^nil ].	(trie includesKey: ((board at: row) at: col)) ifFalse: [ ^nil ].	(visitedPath includes: row @ col) ifTrue: [ ^nil ].   "2.2"   visitedPath addLast: (row @ col).   nextTrie := trie at: ((board at: row) at: col).   (nextTrie includesKey: 'end') ifTrue: [		"if end of word, then add to resultDictDict:			KEY (word--which is value of 'end' key)			VALUE (visitedPath array)"       resultDict at: (nextTrie at: 'end') put: (Array newFrom: visitedPath).   ].   "DFS ON ADJACENT CELLS"   row-1 to: row+1 do: [ :adjRow |       col-1 to: col+1 do: [ :adjCol |           self               dfs: board               trie: nextTrie               row: adjRow 					col: adjCol               visitedPath: visitedPath               resultDict: resultDict       ].    ].    visitedPath removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 05:06' prior: 33779374!dfs: board trie: trie row: row col: col visitedPath: visitedPath resultDict: resultDict	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size)		and: [(col between: 1 and: board size)]) ifFalse: [ ^nil ].	(trie includesKey: ((board at: row) at: col)) ifFalse: [ ^nil ].	(visitedPath includes: row @ col) ifTrue: [ ^nil ].   "2.2"	"ADD TO VISITEDPATH"   visitedPath addLast: (row @ col).   nextTrie := trie at: ((board at: row) at: col).	"if end of word, then add to resultDictDict:		KEY (word--which is value of 'end' key)		VALUE (visitedPath array)"   (nextTrie includesKey: 'end') ifTrue: [       resultDict at: (nextTrie at: 'end') put: (Array newFrom: visitedPath).   ].   "DFS ON ADJACENT CELLS"   row-1 to: row+1 do: [ :adjRow |       col-1 to: col+1 do: [ :adjCol |           self               dfs: board               trie: nextTrie               row: adjRow 					col: adjCol               visitedPath: visitedPath               resultDict: resultDict       ].    ].    visitedPath removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 19:34' prior: 33773631!search: board for: words		"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end': meow}}}}}								 1.1 - Loop through and call DFS on each cell, it will iterate through each letter, and check potential paths					for each letter recursively and whenever a path matches a word in the TRIE (if 'end' key exists -- meaning 					there is key and value in nextTrie/dict), add it's respective path to resultDict!!!!				After loop return resultDict										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result			2.1 - RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if letter is not in trie 					3. if coordinates is already visited in visitedpath								2.2 -	otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"				   | trie resultDict |	"1.0 TRIE CREATION"	trie := Dictionary new.	resultDict := Dictionary new.		words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].		currDict at: 'end' put: word.		].      "1.1 RUN DFS ON EACH CELL"    board do: [ :row |        row do: [ :col |        		self                dfs: board 					trie: trie 					row: row 					col: col 					visitedPath: OrderedCollection new 					resultDict: resultDict        ].    ].    ^resultDict! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 19:38' prior: 33781715!search: board for: words		"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end': meow}}}}}								 1.1 - Loop through and call DFS on each cell, it will iterate through each letter, and check potential paths					for each letter recursively and whenever a path matches a word in the TRIE (if 'end' key exists -- meaning 					there is key and value in nextTrie/dict), add it's respective path to resultDict!!!!				After loop return resultDict										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result			2.1 - RETURN FALSE IF EITHER OF THE FOLLOWING IS TRUE:					1. coordinates not within range of board					2. if letter is not in trie 					3. if coordinates is already visited in visitedpath								2.2 -	otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"				   | trie resultDict |	"1.0 TRIE CREATION"	trie := Dictionary new.	resultDict := Dictionary new.		words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].		currDict at: 'end' put: word.		].      "1.1 RUN DFS ON EACH CELL"    1 to: board size do: [ :row |        1 to: board first size do: [ :col |        		self                dfs: board 					trie: trie 					row: row 					col: col 					visitedPath: OrderedCollection new 					resultDict: resultDict        ].    ].    ^resultDict! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 19:47' prior: 33780535!dfs: board trie: trie row: row col: col visitedPath: visitedPath resultDict: resultDict	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size)		and: [(col between: 1 and: board size)]) ifFalse: [ ^nil ].	(trie includesKey: ((board at: row) at: col)) ifFalse: [ ^nil ].	(visitedPath includes: row @ col) ifTrue: [ ^nil ].   "2.2"	"ADD TO VISITEDPATH"   visitedPath addLast: (row @ col).   nextTrie := trie at: ((board at: row) at: col).	"if end of word, then add to resultDictDict:		KEY (word--which is value of 'end' key)		VALUE (visitedPath array)"   (nextTrie includesKey: 'end') ifTrue: [       resultDict at: (nextTrie at: 'end') put: (Array newFrom: visitedPath).   ].   "DFS ON ADJACENT CELLS"   1 to: 3 do: [ :dy |       1 to: 3 do: [ :dx |				| adjRow adjCol |				adjRow := row + dy - 2.				adjCol := col + dx - 2.         	  	self            		   dfs: board            		   trie: nextTrie            	 	   row: adjRow 						col: adjCol            	 	   visitedPath: visitedPath             	   resultDict: resultDict       ].    ].    visitedPath removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 19:52' prior: 33788411!dfs: board trie: trie row: row col: col visitedPath: visitedPath resultDict: resultDict	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size)     and: [ col between: 1 and: board size 	and: [ trie includesKey: ((board at: row) at: col) ]]) ifFalse: [ ^nil].   "2.2"	"ADD TO VISITEDPATH"   visitedPath addLast: (row @ col).   nextTrie := trie at: ((board at: row) at: col).	"if end of word, then add to resultDictDict:		KEY (word--which is value of 'end' key)		VALUE (visitedPath array)"   (nextTrie includesKey: 'end') ifTrue: [       resultDict at: (nextTrie at: 'end') put: (Array newFrom: visitedPath).   ].   "DFS ON ADJACENT CELLS"   1 to: 3 do: [ :dy |       1 to: 3 do: [ :dx |				| adjRow adjCol |				adjRow := row + dy - 2.				adjCol := col + dx - 2.         	  	self            		   dfs: board            		   trie: nextTrie            	 	   row: adjRow 						col: adjCol            	 	   visitedPath: visitedPath             	   resultDict: resultDict       ].    ].    visitedPath removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 19:58' prior: 33789660!dfs: board trie: trie row: row col: col visitedPath: visitedPath resultDict: resultDict	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size)     and: [ (col between: 1 and: board size) 	 and: [ (trie includesKey: ((board at: row) at: col)) 	 and: [ (visitedPath includes: row @ col) not ] ] ]) ifFalse: [^nil].   "2.2"	"ADD TO VISITEDPATH"   visitedPath addLast: (row @ col).   nextTrie := trie at: ((board at: row) at: col).	"if end of word, then add to resultDictDict:		KEY (word--which is value of 'end' key)		VALUE (visitedPath array)"   (nextTrie includesKey: 'end') ifTrue: [       resultDict at: (nextTrie at: 'end') put: (Array newFrom: visitedPath).   ].   "DFS ON ADJACENT CELLS"   1 to: 3 do: [ :dy |       1 to: 3 do: [ :dx |				| adjRow adjCol |				adjRow := row + dy - 2.				adjCol := col + dx - 2.         	  	self            		   dfs: board            		   trie: nextTrie            	 	   row: adjRow 						col: adjCol            	 	   visitedPath: visitedPath             	   resultDict: resultDict       ].    ].    visitedPath removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 20:06' prior: 33785048!search: board for: words		"PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end': meow}}}}}								 1.1 - Loop through and call DFS on each cell, it will iterate through each letter, and check potential paths					for each letter recursively and whenever a path matches a word in the TRIE (if 'end' key exists -- meaning 					there is key and value in nextTrie/dict), add it's respective path to resultDict!!!!				After loop return resultDict										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result			2.1 - Check for the following:					1. coordinates not within range of board					2. if letter is in trie 					3. if coordinates is already visited in visitedpath								2.2 -	otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"				   | trie resultDict |	"1.0 TRIE CREATION"	trie := Dictionary new.	resultDict := Dictionary new.		words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].		currDict at: 'end' put: word.		].      "1.1 RUN DFS ON EACH CELL"    1 to: board size do: [ :row |        1 to: board first size do: [ :col |        		self                dfs: board 					trie: trie 					row: row 					col: col 					visitedPath: OrderedCollection new 					resultDict: resultDict        ].    ].    ^resultDict! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 20:06' prior: 33790847!dfs: board trie: trie row: row col: col visitedPath: visitedPath resultDict: resultDict	"2.0"   | nextTrie |   "2.1 CONDITIONAL BASE CASE STATEMENTS"   ((row between: 1 and: board size)     and: [ (col between: 1 and: board size) 	 and: [ (trie includesKey: ((board at: row) at: col)) 	 and: [ (visitedPath includes: row @ col) not ] ] ]) ifFalse: [^nil].   "2.2"	"ADD TO VISITEDPATH"   visitedPath addLast: (row @ col).   nextTrie := trie at: ((board at: row) at: col).	"if end of word, then add to resultDictDict:		KEY (word--which is value of 'end' key)		VALUE (visitedPath array)"   (nextTrie includesKey: 'end') ifTrue: [       resultDict at: (nextTrie at: 'end') put: (Array newFrom: visitedPath).   ].   "DFS ON ADJACENT CELLS"   1 to: 3 do: [ :dy |       1 to: 3 do: [ :dx |				| adjRow adjCol |				adjRow := row + dy - 2.				adjCol := col + dx - 2.         	  	self            		   dfs: board            		   trie: nextTrie            	 	   row: adjRow 						col: adjCol            	 	   visitedPath: visitedPath             	   resultDict: resultDict       ].    ].    visitedPath removeLast! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DannyVo 2/25/2024 20:10' prior: 33792089!search: board for: words		"501119407 Danny Vo	PSUEDO CODE: 	for search: board for: words	1.0 - make a trie containing all legal words			todo: iterate over each word and letter of word					check if the letter(key) has a value					if not add an empty dictionary as its value and update curr_trie location to the value of letter 						e.g for word 'meow'						for letter in word:							trie = Dictionary new. -> { : }							curr_trie = trie							does key 'm' have a value in curr_trie? if no then:								add 'm' as KEY								add { : } as VALUE								update curr_trie = {'m' : { : }}														does key 'e' have a value in curr_trie? if no then:								add 'e' as KEY								add { : } as VALUE								update curr_trie = {'m' : {'e' : { : }}} and so on.. until {'m':{'e':{'o':{'w':{:}}}}}						by now, the for loop finishes so we can add one last KEY:VALUE which is 'end' marking the end of word						curr_trie = {{'m':{'e':{'o':{'w':{'end': meow}}}}}								 1.1 - Loop through and call DFS on each cell, it will iterate through each letter, and check potential paths					for each letter recursively and whenever a path matches a word in the TRIE (if 'end' key exists -- meaning 					there is key and value in nextTrie/dict), add it's respective path to resultDict!!!!				After loop return resultDict										for dfs:	 2.0 - a helper function that does DFS search on a cell			todo: 				given coordinates of cell, trie, visitedpath, board, and result			2.1 - Check for the following:					1. coordinates not within range of board					2. if letter is in trie 					3. if coordinates is already visited in visitedpath								2.2 -	otherwise do the following in order:					1.add letter coordinates to visitedpaths					2.check if the next_trie (so next value which contains a dictionary)						if there is a value associated with key 'end', if not return false						else: we found end of word and can add visitedpath (containing coords) to result					3.iterate over adjacent cells recursively calling DFS with next_trie					4.remove current location from visitedpaths 						-explanation for removing: so basically when your iteratinng on cell(2 @ 2) you run DPS on adjacent cells						using a nested loop, so lets say it runs DPS on cell (3@3) for this iteration, it adds (3@3) to the paths						and continues extending until it meets a base case which by then could have added a word to result						dictionary. THEN it removes its current location from visited paths so it can effectively start back						at(2@2) and try the next respective cell with no interference from previous paths (aka visitedpaths)"				   | trie resultDict |	"1.0 TRIE CREATION"	trie := Dictionary new.	resultDict := Dictionary new.		words do: [ :word | 		|currDict|		currDict := trie.		word do: [ :letter | 			currDict := currDict at: letter ifAbsentPut: [Dictionary new]			].		currDict at: 'end' put: word.		].      "1.1 RUN DFS ON EACH CELL"    1 to: board size do: [ :row |        1 to: board first size do: [ :col |        		self                dfs: board 					trie: trie 					row: row 					col: col 					visitedPath: OrderedCollection new 					resultDict: resultDict        ].    ].    ^resultDict! !----QUIT----2024-02-25T20:23:38.325-05:00 BoggleTester.image priorSource: 113447!----QUIT----2024-02-25T22:05:51.862-05:00 BoggleTester.image priorSource: 245488!